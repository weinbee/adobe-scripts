{
  "version": 3,
  "sources": ["../../path/path.js"],
  "sourcesContent": ["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n\nvar isWindows = process.platform === 'win32';\nvar util = require('util');\n\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  var res = [];\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i];\n\n    // ignore empty parts\n    if (!p || p === '.')\n      continue;\n\n    if (p === '..') {\n      if (res.length && res[res.length - 1] !== '..') {\n        res.pop();\n      } else if (allowAboveRoot) {\n        res.push('..');\n      }\n    } else {\n      res.push(p);\n    }\n  }\n\n  return res;\n}\n\n// returns an array with empty elements removed from either end of the input\n// array or the original array if no elements need to be removed\nfunction trimArray(arr) {\n  var lastIndex = arr.length - 1;\n  var start = 0;\n  for (; start <= lastIndex; start++) {\n    if (arr[start])\n      break;\n  }\n\n  var end = lastIndex;\n  for (; end >= 0; end--) {\n    if (arr[end])\n      break;\n  }\n\n  if (start === 0 && end === lastIndex)\n    return arr;\n  if (start > end)\n    return [];\n  return arr.slice(start, end + 1);\n}\n\n// Regex to split a windows path into three parts: [*, device, slash,\n// tail] windows-only\nvar splitDeviceRe =\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\n// Regex to split the tail part of the above into [*, dir, basename, ext]\nvar splitTailRe =\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\n\nvar win32 = {};\n\n// Function to split a filename into [root, dir, basename, ext]\nfunction win32SplitPath(filename) {\n  // Separate device+slash from tail\n  var result = splitDeviceRe.exec(filename),\n      device = (result[1] || '') + (result[2] || ''),\n      tail = result[3] || '';\n  // Split the tail into dir, basename and extension\n  var result2 = splitTailRe.exec(tail),\n      dir = result2[1],\n      basename = result2[2],\n      ext = result2[3];\n  return [device, dir, basename, ext];\n}\n\nfunction win32StatPath(path) {\n  var result = splitDeviceRe.exec(path),\n      device = result[1] || '',\n      isUnc = !!device && device[1] !== ':';\n  return {\n    device: device,\n    isUnc: isUnc,\n    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\n    tail: result[3]\n  };\n}\n\nfunction normalizeUNCRoot(device) {\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\n}\n\n// path.resolve([from ...], to)\nwin32.resolve = function() {\n  var resolvedDevice = '',\n      resolvedTail = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1; i--) {\n    var path;\n    if (i >= 0) {\n      path = arguments[i];\n    } else if (!resolvedDevice) {\n      path = process.cwd();\n    } else {\n      // Windows has the concept of drive-specific current working\n      // directories. If we've resolved a drive letter but not yet an\n      // absolute path, get cwd for that drive. We're sure the device is not\n      // an unc path at this points, because unc paths are always absolute.\n      path = process.env['=' + resolvedDevice];\n      // Verify that a drive-local cwd was found and that it actually points\n      // to our drive. If not, default to the drive's root.\n      if (!path || path.substr(0, 3).toLowerCase() !==\n          resolvedDevice.toLowerCase() + '\\\\') {\n        path = resolvedDevice + '\\\\';\n      }\n    }\n\n    // Skip empty and invalid entries\n    if (!util.isString(path)) {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    var result = win32StatPath(path),\n        device = result.device,\n        isUnc = result.isUnc,\n        isAbsolute = result.isAbsolute,\n        tail = result.tail;\n\n    if (device &&\n        resolvedDevice &&\n        device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n      // This path points to another device so it is not applicable\n      continue;\n    }\n\n    if (!resolvedDevice) {\n      resolvedDevice = device;\n    }\n    if (!resolvedAbsolute) {\n      resolvedTail = tail + '\\\\' + resolvedTail;\n      resolvedAbsolute = isAbsolute;\n    }\n\n    if (resolvedDevice && resolvedAbsolute) {\n      break;\n    }\n  }\n\n  // Convert slashes to backslashes when `resolvedDevice` points to an UNC\n  // root. Also squash multiple slashes into a single one where appropriate.\n  if (isUnc) {\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\n  }\n\n  // At this point the path should be resolved to a full absolute path,\n  // but handle relative paths to be safe (might happen when process.cwd()\n  // fails)\n\n  // Normalize the tail path\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\n                                !resolvedAbsolute).join('\\\\');\n\n  return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n         '.';\n};\n\n\nwin32.normalize = function(path) {\n  var result = win32StatPath(path),\n      device = result.device,\n      isUnc = result.isUnc,\n      isAbsolute = result.isAbsolute,\n      tail = result.tail,\n      trailingSlash = /[\\\\\\/]$/.test(tail);\n\n  // Normalize the tail path\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\n\n  if (!tail && !isAbsolute) {\n    tail = '.';\n  }\n  if (tail && trailingSlash) {\n    tail += '\\\\';\n  }\n\n  // Convert slashes to backslashes when `device` points to an UNC root.\n  // Also squash multiple slashes into a single one where appropriate.\n  if (isUnc) {\n    device = normalizeUNCRoot(device);\n  }\n\n  return device + (isAbsolute ? '\\\\' : '') + tail;\n};\n\n\nwin32.isAbsolute = function(path) {\n  return win32StatPath(path).isAbsolute;\n};\n\nwin32.join = function() {\n  var paths = [];\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i];\n    if (!util.isString(arg)) {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    if (arg) {\n      paths.push(arg);\n    }\n  }\n\n  var joined = paths.join('\\\\');\n\n  // Make sure that the joined path doesn't start with two slashes, because\n  // normalize() will mistake it for an UNC path then.\n  //\n  // This step is skipped when it is very clear that the user actually\n  // intended to point at an UNC path. This is assumed when the first\n  // non-empty string arguments starts with exactly two slashes followed by\n  // at least one more non-slash character.\n  //\n  // Note that for normalize() to treat a path as an UNC path it needs to\n  // have at least 2 components, so we don't filter for that here.\n  // This means that the user can use join to construct UNC paths from\n  // a server name and a share name; for example:\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\n  }\n\n  return win32.normalize(joined);\n};\n\n\n// path.relative(from, to)\n// it will solve the relative path from 'from' to 'to', for instance:\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\nwin32.relative = function(from, to) {\n  from = win32.resolve(from);\n  to = win32.resolve(to);\n\n  // windows is not case sensitive\n  var lowerFrom = from.toLowerCase();\n  var lowerTo = to.toLowerCase();\n\n  var toParts = trimArray(to.split('\\\\'));\n\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\n\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (lowerFromParts[i] !== lowerToParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  if (samePartsLength == 0) {\n    return to;\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('\\\\');\n};\n\n\nwin32._makeLong = function(path) {\n  // Note: this will *probably* throw somewhere.\n  if (!util.isString(path))\n    return path;\n\n  if (!path) {\n    return '';\n  }\n\n  var resolvedPath = win32.resolve(path);\n\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\n    // path is local filesystem path, which needs to be converted\n    // to long UNC path.\n    return '\\\\\\\\?\\\\' + resolvedPath;\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\n    // path is network UNC path, which needs to be converted\n    // to long UNC path.\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\n  }\n\n  return path;\n};\n\n\nwin32.dirname = function(path) {\n  var result = win32SplitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nwin32.basename = function(path, ext) {\n  var f = win32SplitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nwin32.extname = function(path) {\n  return win32SplitPath(path)[3];\n};\n\n\nwin32.format = function(pathObject) {\n  if (!util.isObject(pathObject)) {\n    throw new TypeError(\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\n    );\n  }\n\n  var root = pathObject.root || '';\n\n  if (!util.isString(root)) {\n    throw new TypeError(\n        \"'pathObject.root' must be a string or undefined, not \" +\n        typeof pathObject.root\n    );\n  }\n\n  var dir = pathObject.dir;\n  var base = pathObject.base || '';\n  if (!dir) {\n    return base;\n  }\n  if (dir[dir.length - 1] === win32.sep) {\n    return dir + base;\n  }\n  return dir + win32.sep + base;\n};\n\n\nwin32.parse = function(pathString) {\n  if (!util.isString(pathString)) {\n    throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n    );\n  }\n  var allParts = win32SplitPath(pathString);\n  if (!allParts || allParts.length !== 4) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n};\n\n\nwin32.sep = '\\\\';\nwin32.delimiter = ';';\n\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar posix = {};\n\n\nfunction posixSplitPath(filename) {\n  return splitPathRe.exec(filename).slice(1);\n}\n\n\n// path.resolve([from ...], to)\n// posix version\nposix.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (!util.isString(path)) {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path[0] === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\n                                !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nposix.normalize = function(path) {\n  var isAbsolute = posix.isAbsolute(path),\n      trailingSlash = path && path[path.length - 1] === '/';\n\n  // Normalize the path\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nposix.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nposix.join = function() {\n  var path = '';\n  for (var i = 0; i < arguments.length; i++) {\n    var segment = arguments[i];\n    if (!util.isString(segment)) {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    if (segment) {\n      if (!path) {\n        path += segment;\n      } else {\n        path += '/' + segment;\n      }\n    }\n  }\n  return posix.normalize(path);\n};\n\n\n// path.relative(from, to)\n// posix version\nposix.relative = function(from, to) {\n  from = posix.resolve(from).substr(1);\n  to = posix.resolve(to).substr(1);\n\n  var fromParts = trimArray(from.split('/'));\n  var toParts = trimArray(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n\nposix._makeLong = function(path) {\n  return path;\n};\n\n\nposix.dirname = function(path) {\n  var result = posixSplitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nposix.basename = function(path, ext) {\n  var f = posixSplitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nposix.extname = function(path) {\n  return posixSplitPath(path)[3];\n};\n\n\nposix.format = function(pathObject) {\n  if (!util.isObject(pathObject)) {\n    throw new TypeError(\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\n    );\n  }\n\n  var root = pathObject.root || '';\n\n  if (!util.isString(root)) {\n    throw new TypeError(\n        \"'pathObject.root' must be a string or undefined, not \" +\n        typeof pathObject.root\n    );\n  }\n\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\n  var base = pathObject.base || '';\n  return dir + base;\n};\n\n\nposix.parse = function(pathString) {\n  if (!util.isString(pathString)) {\n    throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n    );\n  }\n  var allParts = posixSplitPath(pathString);\n  if (!allParts || allParts.length !== 4) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n  allParts[1] = allParts[1] || '';\n  allParts[2] = allParts[2] || '';\n  allParts[3] = allParts[3] || '';\n\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n};\n\n\nposix.sep = '/';\nposix.delimiter = ':';\n\n\nif (isWindows)\n  module.exports = win32;\nelse /* posix */\n  module.exports = posix;\n\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n"],
  "mappings": "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",
  "names": []
}
