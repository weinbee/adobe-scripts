{"version":3,"file":"main-4b947e66.js","sources":["../../../node_modules/svelte/internal/index.mjs","../../../src/js/lib/cep/node.ts","../../../src/js/lib/cep/csinterface.js","../../../src/js/lib/cep/vulcan.js","../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/js/lib/utils/bolt.ts","../../../src/js/assets/node-js.svg","../../../src/js/assets/adobe.svg","../../../src/js/assets/bolt-cep.svg","../../../src/js/main/main.svelte","../../../src/js/main/main.ts"],"sourcesContent":["function noop() { }\r\nconst identity = x => x;\r\nfunction assign(tar, src) {\r\n    // @ts-ignore\r\n    for (const k in src)\r\n        tar[k] = src[k];\r\n    return tar;\r\n}\r\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\r\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\r\nfunction is_promise(value) {\r\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\r\n}\r\nfunction add_location(element, file, line, column, char) {\r\n    element.__svelte_meta = {\r\n        loc: { file, line, column, char }\r\n    };\r\n}\r\nfunction run(fn) {\r\n    return fn();\r\n}\r\nfunction blank_object() {\r\n    return Object.create(null);\r\n}\r\nfunction run_all(fns) {\r\n    fns.forEach(run);\r\n}\r\nfunction is_function(thing) {\r\n    return typeof thing === 'function';\r\n}\r\nfunction safe_not_equal(a, b) {\r\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\r\n}\r\nlet src_url_equal_anchor;\r\nfunction src_url_equal(element_src, url) {\r\n    if (!src_url_equal_anchor) {\r\n        src_url_equal_anchor = document.createElement('a');\r\n    }\r\n    src_url_equal_anchor.href = url;\r\n    return element_src === src_url_equal_anchor.href;\r\n}\r\nfunction not_equal(a, b) {\r\n    return a != a ? b == b : a !== b;\r\n}\r\nfunction is_empty(obj) {\r\n    return Object.keys(obj).length === 0;\r\n}\r\nfunction validate_store(store, name) {\r\n    if (store != null && typeof store.subscribe !== 'function') {\r\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\r\n    }\r\n}\r\nfunction subscribe(store, ...callbacks) {\r\n    if (store == null) {\r\n        return noop;\r\n    }\r\n    const unsub = store.subscribe(...callbacks);\r\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\r\n}\r\nfunction get_store_value(store) {\r\n    let value;\r\n    subscribe(store, _ => value = _)();\r\n    return value;\r\n}\r\nfunction component_subscribe(component, store, callback) {\r\n    component.$$.on_destroy.push(subscribe(store, callback));\r\n}\r\nfunction create_slot(definition, ctx, $$scope, fn) {\r\n    if (definition) {\r\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\r\n        return definition[0](slot_ctx);\r\n    }\r\n}\r\nfunction get_slot_context(definition, ctx, $$scope, fn) {\r\n    return definition[1] && fn\r\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\r\n        : $$scope.ctx;\r\n}\r\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\r\n    if (definition[2] && fn) {\r\n        const lets = definition[2](fn(dirty));\r\n        if ($$scope.dirty === undefined) {\r\n            return lets;\r\n        }\r\n        if (typeof lets === 'object') {\r\n            const merged = [];\r\n            const len = Math.max($$scope.dirty.length, lets.length);\r\n            for (let i = 0; i < len; i += 1) {\r\n                merged[i] = $$scope.dirty[i] | lets[i];\r\n            }\r\n            return merged;\r\n        }\r\n        return $$scope.dirty | lets;\r\n    }\r\n    return $$scope.dirty;\r\n}\r\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\r\n    if (slot_changes) {\r\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\r\n        slot.p(slot_context, slot_changes);\r\n    }\r\n}\r\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\r\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\r\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\r\n}\r\nfunction get_all_dirty_from_scope($$scope) {\r\n    if ($$scope.ctx.length > 32) {\r\n        const dirty = [];\r\n        const length = $$scope.ctx.length / 32;\r\n        for (let i = 0; i < length; i++) {\r\n            dirty[i] = -1;\r\n        }\r\n        return dirty;\r\n    }\r\n    return -1;\r\n}\r\nfunction exclude_internal_props(props) {\r\n    const result = {};\r\n    for (const k in props)\r\n        if (k[0] !== '$')\r\n            result[k] = props[k];\r\n    return result;\r\n}\r\nfunction compute_rest_props(props, keys) {\r\n    const rest = {};\r\n    keys = new Set(keys);\r\n    for (const k in props)\r\n        if (!keys.has(k) && k[0] !== '$')\r\n            rest[k] = props[k];\r\n    return rest;\r\n}\r\nfunction compute_slots(slots) {\r\n    const result = {};\r\n    for (const key in slots) {\r\n        result[key] = true;\r\n    }\r\n    return result;\r\n}\r\nfunction once(fn) {\r\n    let ran = false;\r\n    return function (...args) {\r\n        if (ran)\r\n            return;\r\n        ran = true;\r\n        fn.call(this, ...args);\r\n    };\r\n}\r\nfunction null_to_empty(value) {\r\n    return value == null ? '' : value;\r\n}\r\nfunction set_store_value(store, ret, value) {\r\n    store.set(value);\r\n    return ret;\r\n}\r\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\r\nfunction action_destroyer(action_result) {\r\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\r\n}\r\nfunction split_css_unit(value) {\r\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\r\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\r\n}\r\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\r\n\r\nconst is_client = typeof window !== 'undefined';\r\nlet now = is_client\r\n    ? () => window.performance.now()\r\n    : () => Date.now();\r\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\r\n// used internally for testing\r\nfunction set_now(fn) {\r\n    now = fn;\r\n}\r\nfunction set_raf(fn) {\r\n    raf = fn;\r\n}\r\n\r\nconst tasks = new Set();\r\nfunction run_tasks(now) {\r\n    tasks.forEach(task => {\r\n        if (!task.c(now)) {\r\n            tasks.delete(task);\r\n            task.f();\r\n        }\r\n    });\r\n    if (tasks.size !== 0)\r\n        raf(run_tasks);\r\n}\r\n/**\r\n * For testing purposes only!\r\n */\r\nfunction clear_loops() {\r\n    tasks.clear();\r\n}\r\n/**\r\n * Creates a new task that runs on each raf frame\r\n * until it returns a falsy value or is aborted\r\n */\r\nfunction loop(callback) {\r\n    let task;\r\n    if (tasks.size === 0)\r\n        raf(run_tasks);\r\n    return {\r\n        promise: new Promise(fulfill => {\r\n            tasks.add(task = { c: callback, f: fulfill });\r\n        }),\r\n        abort() {\r\n            tasks.delete(task);\r\n        }\r\n    };\r\n}\r\n\r\nconst globals = (typeof window !== 'undefined'\r\n    ? window\r\n    : typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : global);\r\n\r\n/**\r\n * Resize observer singleton.\r\n * One listener per element only!\r\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\r\n */\r\nclass ResizeObserverSingleton {\r\n    constructor(options) {\r\n        this.options = options;\r\n        this._listeners = 'WeakMap' in globals ? new WeakMap() : undefined;\r\n    }\r\n    observe(element, listener) {\r\n        this._listeners.set(element, listener);\r\n        this._getObserver().observe(element, this.options);\r\n        return () => {\r\n            this._listeners.delete(element);\r\n            this._observer.unobserve(element); // this line can probably be removed\r\n        };\r\n    }\r\n    _getObserver() {\r\n        var _a;\r\n        return (_a = this._observer) !== null && _a !== void 0 ? _a : (this._observer = new ResizeObserver((entries) => {\r\n            var _a;\r\n            for (const entry of entries) {\r\n                ResizeObserverSingleton.entries.set(entry.target, entry);\r\n                (_a = this._listeners.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\r\n            }\r\n        }));\r\n    }\r\n}\r\n// Needs to be written like this to pass the tree-shake-test\r\nResizeObserverSingleton.entries = 'WeakMap' in globals ? new WeakMap() : undefined;\r\n\r\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\r\n// at the end of hydration without touching the remaining nodes.\r\nlet is_hydrating = false;\r\nfunction start_hydrating() {\r\n    is_hydrating = true;\r\n}\r\nfunction end_hydrating() {\r\n    is_hydrating = false;\r\n}\r\nfunction upper_bound(low, high, key, value) {\r\n    // Return first index of value larger than input value in the range [low, high)\r\n    while (low < high) {\r\n        const mid = low + ((high - low) >> 1);\r\n        if (key(mid) <= value) {\r\n            low = mid + 1;\r\n        }\r\n        else {\r\n            high = mid;\r\n        }\r\n    }\r\n    return low;\r\n}\r\nfunction init_hydrate(target) {\r\n    if (target.hydrate_init)\r\n        return;\r\n    target.hydrate_init = true;\r\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\r\n    let children = target.childNodes;\r\n    // If target is <head>, there may be children without claim_order\r\n    if (target.nodeName === 'HEAD') {\r\n        const myChildren = [];\r\n        for (let i = 0; i < children.length; i++) {\r\n            const node = children[i];\r\n            if (node.claim_order !== undefined) {\r\n                myChildren.push(node);\r\n            }\r\n        }\r\n        children = myChildren;\r\n    }\r\n    /*\r\n    * Reorder claimed children optimally.\r\n    * We can reorder claimed children optimally by finding the longest subsequence of\r\n    * nodes that are already claimed in order and only moving the rest. The longest\r\n    * subsequence of nodes that are claimed in order can be found by\r\n    * computing the longest increasing subsequence of .claim_order values.\r\n    *\r\n    * This algorithm is optimal in generating the least amount of reorder operations\r\n    * possible.\r\n    *\r\n    * Proof:\r\n    * We know that, given a set of reordering operations, the nodes that do not move\r\n    * always form an increasing subsequence, since they do not move among each other\r\n    * meaning that they must be already ordered among each other. Thus, the maximal\r\n    * set of nodes that do not move form a longest increasing subsequence.\r\n    */\r\n    // Compute longest increasing subsequence\r\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\r\n    const m = new Int32Array(children.length + 1);\r\n    // Predecessor indices + 1\r\n    const p = new Int32Array(children.length);\r\n    m[0] = -1;\r\n    let longest = 0;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const current = children[i].claim_order;\r\n        // Find the largest subsequence length such that it ends in a value less than our current value\r\n        // upper_bound returns first greater value, so we subtract one\r\n        // with fast path for when we are on the current longest subsequence\r\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\r\n        p[i] = m[seqLen] + 1;\r\n        const newLen = seqLen + 1;\r\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\r\n        m[newLen] = i;\r\n        longest = Math.max(newLen, longest);\r\n    }\r\n    // The longest increasing subsequence of nodes (initially reversed)\r\n    const lis = [];\r\n    // The rest of the nodes, nodes that will be moved\r\n    const toMove = [];\r\n    let last = children.length - 1;\r\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\r\n        lis.push(children[cur - 1]);\r\n        for (; last >= cur; last--) {\r\n            toMove.push(children[last]);\r\n        }\r\n        last--;\r\n    }\r\n    for (; last >= 0; last--) {\r\n        toMove.push(children[last]);\r\n    }\r\n    lis.reverse();\r\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\r\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\r\n    // Finally, we move the nodes\r\n    for (let i = 0, j = 0; i < toMove.length; i++) {\r\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\r\n            j++;\r\n        }\r\n        const anchor = j < lis.length ? lis[j] : null;\r\n        target.insertBefore(toMove[i], anchor);\r\n    }\r\n}\r\nfunction append(target, node) {\r\n    target.appendChild(node);\r\n}\r\nfunction append_styles(target, style_sheet_id, styles) {\r\n    const append_styles_to = get_root_for_style(target);\r\n    if (!append_styles_to.getElementById(style_sheet_id)) {\r\n        const style = element('style');\r\n        style.id = style_sheet_id;\r\n        style.textContent = styles;\r\n        append_stylesheet(append_styles_to, style);\r\n    }\r\n}\r\nfunction get_root_for_style(node) {\r\n    if (!node)\r\n        return document;\r\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\r\n    if (root && root.host) {\r\n        return root;\r\n    }\r\n    return node.ownerDocument;\r\n}\r\nfunction append_empty_stylesheet(node) {\r\n    const style_element = element('style');\r\n    append_stylesheet(get_root_for_style(node), style_element);\r\n    return style_element.sheet;\r\n}\r\nfunction append_stylesheet(node, style) {\r\n    append(node.head || node, style);\r\n    return style.sheet;\r\n}\r\nfunction append_hydration(target, node) {\r\n    if (is_hydrating) {\r\n        init_hydrate(target);\r\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\r\n            target.actual_end_child = target.firstChild;\r\n        }\r\n        // Skip nodes of undefined ordering\r\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\r\n            target.actual_end_child = target.actual_end_child.nextSibling;\r\n        }\r\n        if (node !== target.actual_end_child) {\r\n            // We only insert if the ordering of this node should be modified or the parent node is not target\r\n            if (node.claim_order !== undefined || node.parentNode !== target) {\r\n                target.insertBefore(node, target.actual_end_child);\r\n            }\r\n        }\r\n        else {\r\n            target.actual_end_child = node.nextSibling;\r\n        }\r\n    }\r\n    else if (node.parentNode !== target || node.nextSibling !== null) {\r\n        target.appendChild(node);\r\n    }\r\n}\r\nfunction insert(target, node, anchor) {\r\n    target.insertBefore(node, anchor || null);\r\n}\r\nfunction insert_hydration(target, node, anchor) {\r\n    if (is_hydrating && !anchor) {\r\n        append_hydration(target, node);\r\n    }\r\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\r\n        target.insertBefore(node, anchor || null);\r\n    }\r\n}\r\nfunction detach(node) {\r\n    if (node.parentNode) {\r\n        node.parentNode.removeChild(node);\r\n    }\r\n}\r\nfunction destroy_each(iterations, detaching) {\r\n    for (let i = 0; i < iterations.length; i += 1) {\r\n        if (iterations[i])\r\n            iterations[i].d(detaching);\r\n    }\r\n}\r\nfunction element(name) {\r\n    return document.createElement(name);\r\n}\r\nfunction element_is(name, is) {\r\n    return document.createElement(name, { is });\r\n}\r\nfunction object_without_properties(obj, exclude) {\r\n    const target = {};\r\n    for (const k in obj) {\r\n        if (has_prop(obj, k)\r\n            // @ts-ignore\r\n            && exclude.indexOf(k) === -1) {\r\n            // @ts-ignore\r\n            target[k] = obj[k];\r\n        }\r\n    }\r\n    return target;\r\n}\r\nfunction svg_element(name) {\r\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\r\n}\r\nfunction text(data) {\r\n    return document.createTextNode(data);\r\n}\r\nfunction space() {\r\n    return text(' ');\r\n}\r\nfunction empty() {\r\n    return text('');\r\n}\r\nfunction comment(content) {\r\n    return document.createComment(content);\r\n}\r\nfunction listen(node, event, handler, options) {\r\n    node.addEventListener(event, handler, options);\r\n    return () => node.removeEventListener(event, handler, options);\r\n}\r\nfunction prevent_default(fn) {\r\n    return function (event) {\r\n        event.preventDefault();\r\n        // @ts-ignore\r\n        return fn.call(this, event);\r\n    };\r\n}\r\nfunction stop_propagation(fn) {\r\n    return function (event) {\r\n        event.stopPropagation();\r\n        // @ts-ignore\r\n        return fn.call(this, event);\r\n    };\r\n}\r\nfunction stop_immediate_propagation(fn) {\r\n    return function (event) {\r\n        event.stopImmediatePropagation();\r\n        // @ts-ignore\r\n        return fn.call(this, event);\r\n    };\r\n}\r\nfunction self(fn) {\r\n    return function (event) {\r\n        // @ts-ignore\r\n        if (event.target === this)\r\n            fn.call(this, event);\r\n    };\r\n}\r\nfunction trusted(fn) {\r\n    return function (event) {\r\n        // @ts-ignore\r\n        if (event.isTrusted)\r\n            fn.call(this, event);\r\n    };\r\n}\r\nfunction attr(node, attribute, value) {\r\n    if (value == null)\r\n        node.removeAttribute(attribute);\r\n    else if (node.getAttribute(attribute) !== value)\r\n        node.setAttribute(attribute, value);\r\n}\r\n/**\r\n * List of attributes that should always be set through the attr method,\r\n * because updating them through the property setter doesn't work reliably.\r\n * In the example of `width`/`height`, the problem is that the setter only\r\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\r\n * If this list becomes too big, rethink this approach.\r\n */\r\nconst always_set_through_set_attribute = ['width', 'height'];\r\nfunction set_attributes(node, attributes) {\r\n    // @ts-ignore\r\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\r\n    for (const key in attributes) {\r\n        if (attributes[key] == null) {\r\n            node.removeAttribute(key);\r\n        }\r\n        else if (key === 'style') {\r\n            node.style.cssText = attributes[key];\r\n        }\r\n        else if (key === '__value') {\r\n            node.value = node[key] = attributes[key];\r\n        }\r\n        else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\r\n            node[key] = attributes[key];\r\n        }\r\n        else {\r\n            attr(node, key, attributes[key]);\r\n        }\r\n    }\r\n}\r\nfunction set_svg_attributes(node, attributes) {\r\n    for (const key in attributes) {\r\n        attr(node, key, attributes[key]);\r\n    }\r\n}\r\nfunction set_custom_element_data_map(node, data_map) {\r\n    Object.keys(data_map).forEach((key) => {\r\n        set_custom_element_data(node, key, data_map[key]);\r\n    });\r\n}\r\nfunction set_custom_element_data(node, prop, value) {\r\n    if (prop in node) {\r\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\r\n    }\r\n    else {\r\n        attr(node, prop, value);\r\n    }\r\n}\r\nfunction set_dynamic_element_data(tag) {\r\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\r\n}\r\nfunction xlink_attr(node, attribute, value) {\r\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\r\n}\r\nfunction get_binding_group_value(group, __value, checked) {\r\n    const value = new Set();\r\n    for (let i = 0; i < group.length; i += 1) {\r\n        if (group[i].checked)\r\n            value.add(group[i].__value);\r\n    }\r\n    if (!checked) {\r\n        value.delete(__value);\r\n    }\r\n    return Array.from(value);\r\n}\r\nfunction init_binding_group(group) {\r\n    let _inputs;\r\n    return {\r\n        /* push */ p(...inputs) {\r\n            _inputs = inputs;\r\n            _inputs.forEach(input => group.push(input));\r\n        },\r\n        /* remove */ r() {\r\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\r\n        }\r\n    };\r\n}\r\nfunction init_binding_group_dynamic(group, indexes) {\r\n    let _group = get_binding_group(group);\r\n    let _inputs;\r\n    function get_binding_group(group) {\r\n        for (let i = 0; i < indexes.length; i++) {\r\n            group = group[indexes[i]] = group[indexes[i]] || [];\r\n        }\r\n        return group;\r\n    }\r\n    function push() {\r\n        _inputs.forEach(input => _group.push(input));\r\n    }\r\n    function remove() {\r\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\r\n    }\r\n    return {\r\n        /* update */ u(new_indexes) {\r\n            indexes = new_indexes;\r\n            const new_group = get_binding_group(group);\r\n            if (new_group !== _group) {\r\n                remove();\r\n                _group = new_group;\r\n                push();\r\n            }\r\n        },\r\n        /* push */ p(...inputs) {\r\n            _inputs = inputs;\r\n            push();\r\n        },\r\n        /* remove */ r: remove\r\n    };\r\n}\r\nfunction to_number(value) {\r\n    return value === '' ? null : +value;\r\n}\r\nfunction time_ranges_to_array(ranges) {\r\n    const array = [];\r\n    for (let i = 0; i < ranges.length; i += 1) {\r\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\r\n    }\r\n    return array;\r\n}\r\nfunction children(element) {\r\n    return Array.from(element.childNodes);\r\n}\r\nfunction init_claim_info(nodes) {\r\n    if (nodes.claim_info === undefined) {\r\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\r\n    }\r\n}\r\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\r\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\r\n    init_claim_info(nodes);\r\n    const resultNode = (() => {\r\n        // We first try to find an element after the previous one\r\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            if (predicate(node)) {\r\n                const replacement = processNode(node);\r\n                if (replacement === undefined) {\r\n                    nodes.splice(i, 1);\r\n                }\r\n                else {\r\n                    nodes[i] = replacement;\r\n                }\r\n                if (!dontUpdateLastIndex) {\r\n                    nodes.claim_info.last_index = i;\r\n                }\r\n                return node;\r\n            }\r\n        }\r\n        // Otherwise, we try to find one before\r\n        // We iterate in reverse so that we don't go too far back\r\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\r\n            const node = nodes[i];\r\n            if (predicate(node)) {\r\n                const replacement = processNode(node);\r\n                if (replacement === undefined) {\r\n                    nodes.splice(i, 1);\r\n                }\r\n                else {\r\n                    nodes[i] = replacement;\r\n                }\r\n                if (!dontUpdateLastIndex) {\r\n                    nodes.claim_info.last_index = i;\r\n                }\r\n                else if (replacement === undefined) {\r\n                    // Since we spliced before the last_index, we decrease it\r\n                    nodes.claim_info.last_index--;\r\n                }\r\n                return node;\r\n            }\r\n        }\r\n        // If we can't find any matching node, we create a new one\r\n        return createNode();\r\n    })();\r\n    resultNode.claim_order = nodes.claim_info.total_claimed;\r\n    nodes.claim_info.total_claimed += 1;\r\n    return resultNode;\r\n}\r\nfunction claim_element_base(nodes, name, attributes, create_element) {\r\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\r\n        const remove = [];\r\n        for (let j = 0; j < node.attributes.length; j++) {\r\n            const attribute = node.attributes[j];\r\n            if (!attributes[attribute.name]) {\r\n                remove.push(attribute.name);\r\n            }\r\n        }\r\n        remove.forEach(v => node.removeAttribute(v));\r\n        return undefined;\r\n    }, () => create_element(name));\r\n}\r\nfunction claim_element(nodes, name, attributes) {\r\n    return claim_element_base(nodes, name, attributes, element);\r\n}\r\nfunction claim_svg_element(nodes, name, attributes) {\r\n    return claim_element_base(nodes, name, attributes, svg_element);\r\n}\r\nfunction claim_text(nodes, data) {\r\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\r\n        const dataStr = '' + data;\r\n        if (node.data.startsWith(dataStr)) {\r\n            if (node.data.length !== dataStr.length) {\r\n                return node.splitText(dataStr.length);\r\n            }\r\n        }\r\n        else {\r\n            node.data = dataStr;\r\n        }\r\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\r\n    );\r\n}\r\nfunction claim_space(nodes) {\r\n    return claim_text(nodes, ' ');\r\n}\r\nfunction claim_comment(nodes, data) {\r\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\r\n        node.data = '' + data;\r\n        return undefined;\r\n    }, () => comment(data), true);\r\n}\r\nfunction find_comment(nodes, text, start) {\r\n    for (let i = start; i < nodes.length; i += 1) {\r\n        const node = nodes[i];\r\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\r\n            return i;\r\n        }\r\n    }\r\n    return nodes.length;\r\n}\r\nfunction claim_html_tag(nodes, is_svg) {\r\n    // find html opening tag\r\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\r\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\r\n    if (start_index === end_index) {\r\n        return new HtmlTagHydration(undefined, is_svg);\r\n    }\r\n    init_claim_info(nodes);\r\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\r\n    detach(html_tag_nodes[0]);\r\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\r\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\r\n    for (const n of claimed_nodes) {\r\n        n.claim_order = nodes.claim_info.total_claimed;\r\n        nodes.claim_info.total_claimed += 1;\r\n    }\r\n    return new HtmlTagHydration(claimed_nodes, is_svg);\r\n}\r\nfunction set_data(text, data) {\r\n    data = '' + data;\r\n    if (text.data === data)\r\n        return;\r\n    text.data = data;\r\n}\r\nfunction set_data_contenteditable(text, data) {\r\n    data = '' + data;\r\n    if (text.wholeText === data)\r\n        return;\r\n    text.data = data;\r\n}\r\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\r\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\r\n        set_data_contenteditable(text, data);\r\n    }\r\n    else {\r\n        set_data(text, data);\r\n    }\r\n}\r\nfunction set_input_value(input, value) {\r\n    input.value = value == null ? '' : value;\r\n}\r\nfunction set_input_type(input, type) {\r\n    try {\r\n        input.type = type;\r\n    }\r\n    catch (e) {\r\n        // do nothing\r\n    }\r\n}\r\nfunction set_style(node, key, value, important) {\r\n    if (value == null) {\r\n        node.style.removeProperty(key);\r\n    }\r\n    else {\r\n        node.style.setProperty(key, value, important ? 'important' : '');\r\n    }\r\n}\r\nfunction select_option(select, value, mounting) {\r\n    for (let i = 0; i < select.options.length; i += 1) {\r\n        const option = select.options[i];\r\n        if (option.__value === value) {\r\n            option.selected = true;\r\n            return;\r\n        }\r\n    }\r\n    if (!mounting || value !== undefined) {\r\n        select.selectedIndex = -1; // no option should be selected\r\n    }\r\n}\r\nfunction select_options(select, value) {\r\n    for (let i = 0; i < select.options.length; i += 1) {\r\n        const option = select.options[i];\r\n        option.selected = ~value.indexOf(option.__value);\r\n    }\r\n}\r\nfunction select_value(select) {\r\n    const selected_option = select.querySelector(':checked');\r\n    return selected_option && selected_option.__value;\r\n}\r\nfunction select_multiple_value(select) {\r\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\r\n}\r\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\r\n// so we cache the result instead\r\nlet crossorigin;\r\nfunction is_crossorigin() {\r\n    if (crossorigin === undefined) {\r\n        crossorigin = false;\r\n        try {\r\n            if (typeof window !== 'undefined' && window.parent) {\r\n                void window.parent.document;\r\n            }\r\n        }\r\n        catch (error) {\r\n            crossorigin = true;\r\n        }\r\n    }\r\n    return crossorigin;\r\n}\r\nfunction add_iframe_resize_listener(node, fn) {\r\n    const computed_style = getComputedStyle(node);\r\n    if (computed_style.position === 'static') {\r\n        node.style.position = 'relative';\r\n    }\r\n    const iframe = element('iframe');\r\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\r\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\r\n    iframe.setAttribute('aria-hidden', 'true');\r\n    iframe.tabIndex = -1;\r\n    const crossorigin = is_crossorigin();\r\n    let unsubscribe;\r\n    if (crossorigin) {\r\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\r\n        unsubscribe = listen(window, 'message', (event) => {\r\n            if (event.source === iframe.contentWindow)\r\n                fn();\r\n        });\r\n    }\r\n    else {\r\n        iframe.src = 'about:blank';\r\n        iframe.onload = () => {\r\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\r\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\r\n            // see https://github.com/sveltejs/svelte/issues/4233\r\n            fn();\r\n        };\r\n    }\r\n    append(node, iframe);\r\n    return () => {\r\n        if (crossorigin) {\r\n            unsubscribe();\r\n        }\r\n        else if (unsubscribe && iframe.contentWindow) {\r\n            unsubscribe();\r\n        }\r\n        detach(iframe);\r\n    };\r\n}\r\nconst resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'content-box' });\r\nconst resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'border-box' });\r\nconst resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'device-pixel-content-box' });\r\nfunction toggle_class(element, name, toggle) {\r\n    element.classList[toggle ? 'add' : 'remove'](name);\r\n}\r\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\r\n    const e = document.createEvent('CustomEvent');\r\n    e.initCustomEvent(type, bubbles, cancelable, detail);\r\n    return e;\r\n}\r\nfunction query_selector_all(selector, parent = document.body) {\r\n    return Array.from(parent.querySelectorAll(selector));\r\n}\r\nfunction head_selector(nodeId, head) {\r\n    const result = [];\r\n    let started = 0;\r\n    for (const node of head.childNodes) {\r\n        if (node.nodeType === 8 /* comment node */) {\r\n            const comment = node.textContent.trim();\r\n            if (comment === `HEAD_${nodeId}_END`) {\r\n                started -= 1;\r\n                result.push(node);\r\n            }\r\n            else if (comment === `HEAD_${nodeId}_START`) {\r\n                started += 1;\r\n                result.push(node);\r\n            }\r\n        }\r\n        else if (started > 0) {\r\n            result.push(node);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nclass HtmlTag {\r\n    constructor(is_svg = false) {\r\n        this.is_svg = false;\r\n        this.is_svg = is_svg;\r\n        this.e = this.n = null;\r\n    }\r\n    c(html) {\r\n        this.h(html);\r\n    }\r\n    m(html, target, anchor = null) {\r\n        if (!this.e) {\r\n            if (this.is_svg)\r\n                this.e = svg_element(target.nodeName);\r\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\r\n            else\r\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\r\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\r\n            this.c(html);\r\n        }\r\n        this.i(anchor);\r\n    }\r\n    h(html) {\r\n        this.e.innerHTML = html;\r\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\r\n    }\r\n    i(anchor) {\r\n        for (let i = 0; i < this.n.length; i += 1) {\r\n            insert(this.t, this.n[i], anchor);\r\n        }\r\n    }\r\n    p(html) {\r\n        this.d();\r\n        this.h(html);\r\n        this.i(this.a);\r\n    }\r\n    d() {\r\n        this.n.forEach(detach);\r\n    }\r\n}\r\nclass HtmlTagHydration extends HtmlTag {\r\n    constructor(claimed_nodes, is_svg = false) {\r\n        super(is_svg);\r\n        this.e = this.n = null;\r\n        this.l = claimed_nodes;\r\n    }\r\n    c(html) {\r\n        if (this.l) {\r\n            this.n = this.l;\r\n        }\r\n        else {\r\n            super.c(html);\r\n        }\r\n    }\r\n    i(anchor) {\r\n        for (let i = 0; i < this.n.length; i += 1) {\r\n            insert_hydration(this.t, this.n[i], anchor);\r\n        }\r\n    }\r\n}\r\nfunction attribute_to_object(attributes) {\r\n    const result = {};\r\n    for (const attribute of attributes) {\r\n        result[attribute.name] = attribute.value;\r\n    }\r\n    return result;\r\n}\r\nfunction get_custom_elements_slots(element) {\r\n    const result = {};\r\n    element.childNodes.forEach((node) => {\r\n        result[node.slot || 'default'] = true;\r\n    });\r\n    return result;\r\n}\r\nfunction construct_svelte_component(component, props) {\r\n    return new component(props);\r\n}\r\n\r\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\r\n// https://github.com/sveltejs/svelte/issues/3624\r\nconst managed_styles = new Map();\r\nlet active = 0;\r\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\r\nfunction hash(str) {\r\n    let hash = 5381;\r\n    let i = str.length;\r\n    while (i--)\r\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\r\n    return hash >>> 0;\r\n}\r\nfunction create_style_information(doc, node) {\r\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\r\n    managed_styles.set(doc, info);\r\n    return info;\r\n}\r\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\r\n    const step = 16.666 / duration;\r\n    let keyframes = '{\\n';\r\n    for (let p = 0; p <= 1; p += step) {\r\n        const t = a + (b - a) * ease(p);\r\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\r\n    }\r\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\r\n    const name = `__svelte_${hash(rule)}_${uid}`;\r\n    const doc = get_root_for_style(node);\r\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\r\n    if (!rules[name]) {\r\n        rules[name] = true;\r\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\r\n    }\r\n    const animation = node.style.animation || '';\r\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\r\n    active += 1;\r\n    return name;\r\n}\r\nfunction delete_rule(node, name) {\r\n    const previous = (node.style.animation || '').split(', ');\r\n    const next = previous.filter(name\r\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\r\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\r\n    );\r\n    const deleted = previous.length - next.length;\r\n    if (deleted) {\r\n        node.style.animation = next.join(', ');\r\n        active -= deleted;\r\n        if (!active)\r\n            clear_rules();\r\n    }\r\n}\r\nfunction clear_rules() {\r\n    raf(() => {\r\n        if (active)\r\n            return;\r\n        managed_styles.forEach(info => {\r\n            const { ownerNode } = info.stylesheet;\r\n            // there is no ownerNode if it runs on jsdom.\r\n            if (ownerNode)\r\n                detach(ownerNode);\r\n        });\r\n        managed_styles.clear();\r\n    });\r\n}\r\n\r\nfunction create_animation(node, from, fn, params) {\r\n    if (!from)\r\n        return noop;\r\n    const to = node.getBoundingClientRect();\r\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\r\n        return noop;\r\n    const { delay = 0, duration = 300, easing = identity, \r\n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\r\n    start: start_time = now() + delay, \r\n    // @ts-ignore todo:\r\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\r\n    let running = true;\r\n    let started = false;\r\n    let name;\r\n    function start() {\r\n        if (css) {\r\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\r\n        }\r\n        if (!delay) {\r\n            started = true;\r\n        }\r\n    }\r\n    function stop() {\r\n        if (css)\r\n            delete_rule(node, name);\r\n        running = false;\r\n    }\r\n    loop(now => {\r\n        if (!started && now >= start_time) {\r\n            started = true;\r\n        }\r\n        if (started && now >= end) {\r\n            tick(1, 0);\r\n            stop();\r\n        }\r\n        if (!running) {\r\n            return false;\r\n        }\r\n        if (started) {\r\n            const p = now - start_time;\r\n            const t = 0 + 1 * easing(p / duration);\r\n            tick(t, 1 - t);\r\n        }\r\n        return true;\r\n    });\r\n    start();\r\n    tick(0, 1);\r\n    return stop;\r\n}\r\nfunction fix_position(node) {\r\n    const style = getComputedStyle(node);\r\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\r\n        const { width, height } = style;\r\n        const a = node.getBoundingClientRect();\r\n        node.style.position = 'absolute';\r\n        node.style.width = width;\r\n        node.style.height = height;\r\n        add_transform(node, a);\r\n    }\r\n}\r\nfunction add_transform(node, a) {\r\n    const b = node.getBoundingClientRect();\r\n    if (a.left !== b.left || a.top !== b.top) {\r\n        const style = getComputedStyle(node);\r\n        const transform = style.transform === 'none' ? '' : style.transform;\r\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\r\n    }\r\n}\r\n\r\nlet current_component;\r\nfunction set_current_component(component) {\r\n    current_component = component;\r\n}\r\nfunction get_current_component() {\r\n    if (!current_component)\r\n        throw new Error('Function called outside component initialization');\r\n    return current_component;\r\n}\r\n/**\r\n * Schedules a callback to run immediately before the component is updated after any state change.\r\n *\r\n * The first time the callback runs will be before the initial `onMount`\r\n *\r\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\r\n */\r\nfunction beforeUpdate(fn) {\r\n    get_current_component().$$.before_update.push(fn);\r\n}\r\n/**\r\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\r\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\r\n * it can be called from an external module).\r\n *\r\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\r\n *\r\n * https://svelte.dev/docs#run-time-svelte-onmount\r\n */\r\nfunction onMount(fn) {\r\n    get_current_component().$$.on_mount.push(fn);\r\n}\r\n/**\r\n * Schedules a callback to run immediately after the component has been updated.\r\n *\r\n * The first time the callback runs will be after the initial `onMount`\r\n */\r\nfunction afterUpdate(fn) {\r\n    get_current_component().$$.after_update.push(fn);\r\n}\r\n/**\r\n * Schedules a callback to run immediately before the component is unmounted.\r\n *\r\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\r\n * only one that runs inside a server-side component.\r\n *\r\n * https://svelte.dev/docs#run-time-svelte-ondestroy\r\n */\r\nfunction onDestroy(fn) {\r\n    get_current_component().$$.on_destroy.push(fn);\r\n}\r\n/**\r\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\r\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\r\n *\r\n * Component events created with `createEventDispatcher` create a\r\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\r\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\r\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\r\n * property and can contain any type of data.\r\n *\r\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\r\n */\r\nfunction createEventDispatcher() {\r\n    const component = get_current_component();\r\n    return (type, detail, { cancelable = false } = {}) => {\r\n        const callbacks = component.$$.callbacks[type];\r\n        if (callbacks) {\r\n            // TODO are there situations where events could be dispatched\r\n            // in a server (non-DOM) environment?\r\n            const event = custom_event(type, detail, { cancelable });\r\n            callbacks.slice().forEach(fn => {\r\n                fn.call(component, event);\r\n            });\r\n            return !event.defaultPrevented;\r\n        }\r\n        return true;\r\n    };\r\n}\r\n/**\r\n * Associates an arbitrary `context` object with the current component and the specified `key`\r\n * and returns that object. The context is then available to children of the component\r\n * (including slotted content) with `getContext`.\r\n *\r\n * Like lifecycle functions, this must be called during component initialisation.\r\n *\r\n * https://svelte.dev/docs#run-time-svelte-setcontext\r\n */\r\nfunction setContext(key, context) {\r\n    get_current_component().$$.context.set(key, context);\r\n    return context;\r\n}\r\n/**\r\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\r\n * Must be called during component initialisation.\r\n *\r\n * https://svelte.dev/docs#run-time-svelte-getcontext\r\n */\r\nfunction getContext(key) {\r\n    return get_current_component().$$.context.get(key);\r\n}\r\n/**\r\n * Retrieves the whole context map that belongs to the closest parent component.\r\n * Must be called during component initialisation. Useful, for example, if you\r\n * programmatically create a component and want to pass the existing context to it.\r\n *\r\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\r\n */\r\nfunction getAllContexts() {\r\n    return get_current_component().$$.context;\r\n}\r\n/**\r\n * Checks whether a given `key` has been set in the context of a parent component.\r\n * Must be called during component initialisation.\r\n *\r\n * https://svelte.dev/docs#run-time-svelte-hascontext\r\n */\r\nfunction hasContext(key) {\r\n    return get_current_component().$$.context.has(key);\r\n}\r\n// TODO figure out if we still want to support\r\n// shorthand events, or if we want to implement\r\n// a real bubbling mechanism\r\nfunction bubble(component, event) {\r\n    const callbacks = component.$$.callbacks[event.type];\r\n    if (callbacks) {\r\n        // @ts-ignore\r\n        callbacks.slice().forEach(fn => fn.call(this, event));\r\n    }\r\n}\r\n\r\nconst dirty_components = [];\r\nconst intros = { enabled: false };\r\nconst binding_callbacks = [];\r\nlet render_callbacks = [];\r\nconst flush_callbacks = [];\r\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\r\nlet update_scheduled = false;\r\nfunction schedule_update() {\r\n    if (!update_scheduled) {\r\n        update_scheduled = true;\r\n        resolved_promise.then(flush);\r\n    }\r\n}\r\nfunction tick() {\r\n    schedule_update();\r\n    return resolved_promise;\r\n}\r\nfunction add_render_callback(fn) {\r\n    render_callbacks.push(fn);\r\n}\r\nfunction add_flush_callback(fn) {\r\n    flush_callbacks.push(fn);\r\n}\r\n// flush() calls callbacks in this order:\r\n// 1. All beforeUpdate callbacks, in order: parents before children\r\n// 2. All bind:this callbacks, in reverse order: children before parents.\r\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\r\n//    for afterUpdates called during the initial onMount, which are called in\r\n//    reverse order: children before parents.\r\n// Since callbacks might update component values, which could trigger another\r\n// call to flush(), the following steps guard against this:\r\n// 1. During beforeUpdate, any updated components will be added to the\r\n//    dirty_components array and will cause a reentrant call to flush(). Because\r\n//    the flush index is kept outside the function, the reentrant call will pick\r\n//    up where the earlier call left off and go through all dirty components. The\r\n//    current_component value is saved and restored so that the reentrant call will\r\n//    not interfere with the \"parent\" flush() call.\r\n// 2. bind:this callbacks cannot trigger new flush() calls.\r\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\r\n//    callback called a second time; the seen_callbacks set, outside the flush()\r\n//    function, guarantees this behavior.\r\nconst seen_callbacks = new Set();\r\nlet flushidx = 0; // Do *not* move this inside the flush() function\r\nfunction flush() {\r\n    // Do not reenter flush while dirty components are updated, as this can\r\n    // result in an infinite loop. Instead, let the inner flush handle it.\r\n    // Reentrancy is ok afterwards for bindings etc.\r\n    if (flushidx !== 0) {\r\n        return;\r\n    }\r\n    const saved_component = current_component;\r\n    do {\r\n        // first, call beforeUpdate functions\r\n        // and update components\r\n        try {\r\n            while (flushidx < dirty_components.length) {\r\n                const component = dirty_components[flushidx];\r\n                flushidx++;\r\n                set_current_component(component);\r\n                update(component.$$);\r\n            }\r\n        }\r\n        catch (e) {\r\n            // reset dirty state to not end up in a deadlocked state and then rethrow\r\n            dirty_components.length = 0;\r\n            flushidx = 0;\r\n            throw e;\r\n        }\r\n        set_current_component(null);\r\n        dirty_components.length = 0;\r\n        flushidx = 0;\r\n        while (binding_callbacks.length)\r\n            binding_callbacks.pop()();\r\n        // then, once components are updated, call\r\n        // afterUpdate functions. This may cause\r\n        // subsequent updates...\r\n        for (let i = 0; i < render_callbacks.length; i += 1) {\r\n            const callback = render_callbacks[i];\r\n            if (!seen_callbacks.has(callback)) {\r\n                // ...so guard against infinite loops\r\n                seen_callbacks.add(callback);\r\n                callback();\r\n            }\r\n        }\r\n        render_callbacks.length = 0;\r\n    } while (dirty_components.length);\r\n    while (flush_callbacks.length) {\r\n        flush_callbacks.pop()();\r\n    }\r\n    update_scheduled = false;\r\n    seen_callbacks.clear();\r\n    set_current_component(saved_component);\r\n}\r\nfunction update($$) {\r\n    if ($$.fragment !== null) {\r\n        $$.update();\r\n        run_all($$.before_update);\r\n        const dirty = $$.dirty;\r\n        $$.dirty = [-1];\r\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\r\n        $$.after_update.forEach(add_render_callback);\r\n    }\r\n}\r\n/**\r\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\r\n */\r\nfunction flush_render_callbacks(fns) {\r\n    const filtered = [];\r\n    const targets = [];\r\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\r\n    targets.forEach((c) => c());\r\n    render_callbacks = filtered;\r\n}\r\n\r\nlet promise;\r\nfunction wait() {\r\n    if (!promise) {\r\n        promise = Promise.resolve();\r\n        promise.then(() => {\r\n            promise = null;\r\n        });\r\n    }\r\n    return promise;\r\n}\r\nfunction dispatch(node, direction, kind) {\r\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\r\n}\r\nconst outroing = new Set();\r\nlet outros;\r\nfunction group_outros() {\r\n    outros = {\r\n        r: 0,\r\n        c: [],\r\n        p: outros // parent group\r\n    };\r\n}\r\nfunction check_outros() {\r\n    if (!outros.r) {\r\n        run_all(outros.c);\r\n    }\r\n    outros = outros.p;\r\n}\r\nfunction transition_in(block, local) {\r\n    if (block && block.i) {\r\n        outroing.delete(block);\r\n        block.i(local);\r\n    }\r\n}\r\nfunction transition_out(block, local, detach, callback) {\r\n    if (block && block.o) {\r\n        if (outroing.has(block))\r\n            return;\r\n        outroing.add(block);\r\n        outros.c.push(() => {\r\n            outroing.delete(block);\r\n            if (callback) {\r\n                if (detach)\r\n                    block.d(1);\r\n                callback();\r\n            }\r\n        });\r\n        block.o(local);\r\n    }\r\n    else if (callback) {\r\n        callback();\r\n    }\r\n}\r\nconst null_transition = { duration: 0 };\r\nfunction create_in_transition(node, fn, params) {\r\n    const options = { direction: 'in' };\r\n    let config = fn(node, params, options);\r\n    let running = false;\r\n    let animation_name;\r\n    let task;\r\n    let uid = 0;\r\n    function cleanup() {\r\n        if (animation_name)\r\n            delete_rule(node, animation_name);\r\n    }\r\n    function go() {\r\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\r\n        if (css)\r\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\r\n        tick(0, 1);\r\n        const start_time = now() + delay;\r\n        const end_time = start_time + duration;\r\n        if (task)\r\n            task.abort();\r\n        running = true;\r\n        add_render_callback(() => dispatch(node, true, 'start'));\r\n        task = loop(now => {\r\n            if (running) {\r\n                if (now >= end_time) {\r\n                    tick(1, 0);\r\n                    dispatch(node, true, 'end');\r\n                    cleanup();\r\n                    return running = false;\r\n                }\r\n                if (now >= start_time) {\r\n                    const t = easing((now - start_time) / duration);\r\n                    tick(t, 1 - t);\r\n                }\r\n            }\r\n            return running;\r\n        });\r\n    }\r\n    let started = false;\r\n    return {\r\n        start() {\r\n            if (started)\r\n                return;\r\n            started = true;\r\n            delete_rule(node);\r\n            if (is_function(config)) {\r\n                config = config(options);\r\n                wait().then(go);\r\n            }\r\n            else {\r\n                go();\r\n            }\r\n        },\r\n        invalidate() {\r\n            started = false;\r\n        },\r\n        end() {\r\n            if (running) {\r\n                cleanup();\r\n                running = false;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction create_out_transition(node, fn, params) {\r\n    const options = { direction: 'out' };\r\n    let config = fn(node, params, options);\r\n    let running = true;\r\n    let animation_name;\r\n    const group = outros;\r\n    group.r += 1;\r\n    function go() {\r\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\r\n        if (css)\r\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\r\n        const start_time = now() + delay;\r\n        const end_time = start_time + duration;\r\n        add_render_callback(() => dispatch(node, false, 'start'));\r\n        loop(now => {\r\n            if (running) {\r\n                if (now >= end_time) {\r\n                    tick(0, 1);\r\n                    dispatch(node, false, 'end');\r\n                    if (!--group.r) {\r\n                        // this will result in `end()` being called,\r\n                        // so we don't need to clean up here\r\n                        run_all(group.c);\r\n                    }\r\n                    return false;\r\n                }\r\n                if (now >= start_time) {\r\n                    const t = easing((now - start_time) / duration);\r\n                    tick(1 - t, t);\r\n                }\r\n            }\r\n            return running;\r\n        });\r\n    }\r\n    if (is_function(config)) {\r\n        wait().then(() => {\r\n            // @ts-ignore\r\n            config = config(options);\r\n            go();\r\n        });\r\n    }\r\n    else {\r\n        go();\r\n    }\r\n    return {\r\n        end(reset) {\r\n            if (reset && config.tick) {\r\n                config.tick(1, 0);\r\n            }\r\n            if (running) {\r\n                if (animation_name)\r\n                    delete_rule(node, animation_name);\r\n                running = false;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction create_bidirectional_transition(node, fn, params, intro) {\r\n    const options = { direction: 'both' };\r\n    let config = fn(node, params, options);\r\n    let t = intro ? 0 : 1;\r\n    let running_program = null;\r\n    let pending_program = null;\r\n    let animation_name = null;\r\n    function clear_animation() {\r\n        if (animation_name)\r\n            delete_rule(node, animation_name);\r\n    }\r\n    function init(program, duration) {\r\n        const d = (program.b - t);\r\n        duration *= Math.abs(d);\r\n        return {\r\n            a: t,\r\n            b: program.b,\r\n            d,\r\n            duration,\r\n            start: program.start,\r\n            end: program.start + duration,\r\n            group: program.group\r\n        };\r\n    }\r\n    function go(b) {\r\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\r\n        const program = {\r\n            start: now() + delay,\r\n            b\r\n        };\r\n        if (!b) {\r\n            // @ts-ignore todo: improve typings\r\n            program.group = outros;\r\n            outros.r += 1;\r\n        }\r\n        if (running_program || pending_program) {\r\n            pending_program = program;\r\n        }\r\n        else {\r\n            // if this is an intro, and there's a delay, we need to do\r\n            // an initial tick and/or apply CSS animation immediately\r\n            if (css) {\r\n                clear_animation();\r\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\r\n            }\r\n            if (b)\r\n                tick(0, 1);\r\n            running_program = init(program, duration);\r\n            add_render_callback(() => dispatch(node, b, 'start'));\r\n            loop(now => {\r\n                if (pending_program && now > pending_program.start) {\r\n                    running_program = init(pending_program, duration);\r\n                    pending_program = null;\r\n                    dispatch(node, running_program.b, 'start');\r\n                    if (css) {\r\n                        clear_animation();\r\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\r\n                    }\r\n                }\r\n                if (running_program) {\r\n                    if (now >= running_program.end) {\r\n                        tick(t = running_program.b, 1 - t);\r\n                        dispatch(node, running_program.b, 'end');\r\n                        if (!pending_program) {\r\n                            // we're done\r\n                            if (running_program.b) {\r\n                                // intro — we can tidy up immediately\r\n                                clear_animation();\r\n                            }\r\n                            else {\r\n                                // outro — needs to be coordinated\r\n                                if (!--running_program.group.r)\r\n                                    run_all(running_program.group.c);\r\n                            }\r\n                        }\r\n                        running_program = null;\r\n                    }\r\n                    else if (now >= running_program.start) {\r\n                        const p = now - running_program.start;\r\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\r\n                        tick(t, 1 - t);\r\n                    }\r\n                }\r\n                return !!(running_program || pending_program);\r\n            });\r\n        }\r\n    }\r\n    return {\r\n        run(b) {\r\n            if (is_function(config)) {\r\n                wait().then(() => {\r\n                    // @ts-ignore\r\n                    config = config(options);\r\n                    go(b);\r\n                });\r\n            }\r\n            else {\r\n                go(b);\r\n            }\r\n        },\r\n        end() {\r\n            clear_animation();\r\n            running_program = pending_program = null;\r\n        }\r\n    };\r\n}\r\n\r\nfunction handle_promise(promise, info) {\r\n    const token = info.token = {};\r\n    function update(type, index, key, value) {\r\n        if (info.token !== token)\r\n            return;\r\n        info.resolved = value;\r\n        let child_ctx = info.ctx;\r\n        if (key !== undefined) {\r\n            child_ctx = child_ctx.slice();\r\n            child_ctx[key] = value;\r\n        }\r\n        const block = type && (info.current = type)(child_ctx);\r\n        let needs_flush = false;\r\n        if (info.block) {\r\n            if (info.blocks) {\r\n                info.blocks.forEach((block, i) => {\r\n                    if (i !== index && block) {\r\n                        group_outros();\r\n                        transition_out(block, 1, 1, () => {\r\n                            if (info.blocks[i] === block) {\r\n                                info.blocks[i] = null;\r\n                            }\r\n                        });\r\n                        check_outros();\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                info.block.d(1);\r\n            }\r\n            block.c();\r\n            transition_in(block, 1);\r\n            block.m(info.mount(), info.anchor);\r\n            needs_flush = true;\r\n        }\r\n        info.block = block;\r\n        if (info.blocks)\r\n            info.blocks[index] = block;\r\n        if (needs_flush) {\r\n            flush();\r\n        }\r\n    }\r\n    if (is_promise(promise)) {\r\n        const current_component = get_current_component();\r\n        promise.then(value => {\r\n            set_current_component(current_component);\r\n            update(info.then, 1, info.value, value);\r\n            set_current_component(null);\r\n        }, error => {\r\n            set_current_component(current_component);\r\n            update(info.catch, 2, info.error, error);\r\n            set_current_component(null);\r\n            if (!info.hasCatch) {\r\n                throw error;\r\n            }\r\n        });\r\n        // if we previously had a then/catch block, destroy it\r\n        if (info.current !== info.pending) {\r\n            update(info.pending, 0);\r\n            return true;\r\n        }\r\n    }\r\n    else {\r\n        if (info.current !== info.then) {\r\n            update(info.then, 1, info.value, promise);\r\n            return true;\r\n        }\r\n        info.resolved = promise;\r\n    }\r\n}\r\nfunction update_await_block_branch(info, ctx, dirty) {\r\n    const child_ctx = ctx.slice();\r\n    const { resolved } = info;\r\n    if (info.current === info.then) {\r\n        child_ctx[info.value] = resolved;\r\n    }\r\n    if (info.current === info.catch) {\r\n        child_ctx[info.error] = resolved;\r\n    }\r\n    info.block.p(child_ctx, dirty);\r\n}\r\n\r\nfunction destroy_block(block, lookup) {\r\n    block.d(1);\r\n    lookup.delete(block.key);\r\n}\r\nfunction outro_and_destroy_block(block, lookup) {\r\n    transition_out(block, 1, 1, () => {\r\n        lookup.delete(block.key);\r\n    });\r\n}\r\nfunction fix_and_destroy_block(block, lookup) {\r\n    block.f();\r\n    destroy_block(block, lookup);\r\n}\r\nfunction fix_and_outro_and_destroy_block(block, lookup) {\r\n    block.f();\r\n    outro_and_destroy_block(block, lookup);\r\n}\r\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\r\n    let o = old_blocks.length;\r\n    let n = list.length;\r\n    let i = o;\r\n    const old_indexes = {};\r\n    while (i--)\r\n        old_indexes[old_blocks[i].key] = i;\r\n    const new_blocks = [];\r\n    const new_lookup = new Map();\r\n    const deltas = new Map();\r\n    const updates = [];\r\n    i = n;\r\n    while (i--) {\r\n        const child_ctx = get_context(ctx, list, i);\r\n        const key = get_key(child_ctx);\r\n        let block = lookup.get(key);\r\n        if (!block) {\r\n            block = create_each_block(key, child_ctx);\r\n            block.c();\r\n        }\r\n        else if (dynamic) {\r\n            // defer updates until all the DOM shuffling is done\r\n            updates.push(() => block.p(child_ctx, dirty));\r\n        }\r\n        new_lookup.set(key, new_blocks[i] = block);\r\n        if (key in old_indexes)\r\n            deltas.set(key, Math.abs(i - old_indexes[key]));\r\n    }\r\n    const will_move = new Set();\r\n    const did_move = new Set();\r\n    function insert(block) {\r\n        transition_in(block, 1);\r\n        block.m(node, next);\r\n        lookup.set(block.key, block);\r\n        next = block.first;\r\n        n--;\r\n    }\r\n    while (o && n) {\r\n        const new_block = new_blocks[n - 1];\r\n        const old_block = old_blocks[o - 1];\r\n        const new_key = new_block.key;\r\n        const old_key = old_block.key;\r\n        if (new_block === old_block) {\r\n            // do nothing\r\n            next = new_block.first;\r\n            o--;\r\n            n--;\r\n        }\r\n        else if (!new_lookup.has(old_key)) {\r\n            // remove old block\r\n            destroy(old_block, lookup);\r\n            o--;\r\n        }\r\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\r\n            insert(new_block);\r\n        }\r\n        else if (did_move.has(old_key)) {\r\n            o--;\r\n        }\r\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\r\n            did_move.add(new_key);\r\n            insert(new_block);\r\n        }\r\n        else {\r\n            will_move.add(old_key);\r\n            o--;\r\n        }\r\n    }\r\n    while (o--) {\r\n        const old_block = old_blocks[o];\r\n        if (!new_lookup.has(old_block.key))\r\n            destroy(old_block, lookup);\r\n    }\r\n    while (n)\r\n        insert(new_blocks[n - 1]);\r\n    run_all(updates);\r\n    return new_blocks;\r\n}\r\nfunction validate_each_keys(ctx, list, get_context, get_key) {\r\n    const keys = new Set();\r\n    for (let i = 0; i < list.length; i++) {\r\n        const key = get_key(get_context(ctx, list, i));\r\n        if (keys.has(key)) {\r\n            throw new Error('Cannot have duplicate keys in a keyed each');\r\n        }\r\n        keys.add(key);\r\n    }\r\n}\r\n\r\nfunction get_spread_update(levels, updates) {\r\n    const update = {};\r\n    const to_null_out = {};\r\n    const accounted_for = { $$scope: 1 };\r\n    let i = levels.length;\r\n    while (i--) {\r\n        const o = levels[i];\r\n        const n = updates[i];\r\n        if (n) {\r\n            for (const key in o) {\r\n                if (!(key in n))\r\n                    to_null_out[key] = 1;\r\n            }\r\n            for (const key in n) {\r\n                if (!accounted_for[key]) {\r\n                    update[key] = n[key];\r\n                    accounted_for[key] = 1;\r\n                }\r\n            }\r\n            levels[i] = n;\r\n        }\r\n        else {\r\n            for (const key in o) {\r\n                accounted_for[key] = 1;\r\n            }\r\n        }\r\n    }\r\n    for (const key in to_null_out) {\r\n        if (!(key in update))\r\n            update[key] = undefined;\r\n    }\r\n    return update;\r\n}\r\nfunction get_spread_object(spread_props) {\r\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\r\n}\r\n\r\nconst _boolean_attributes = [\r\n    'allowfullscreen',\r\n    'allowpaymentrequest',\r\n    'async',\r\n    'autofocus',\r\n    'autoplay',\r\n    'checked',\r\n    'controls',\r\n    'default',\r\n    'defer',\r\n    'disabled',\r\n    'formnovalidate',\r\n    'hidden',\r\n    'inert',\r\n    'ismap',\r\n    'loop',\r\n    'multiple',\r\n    'muted',\r\n    'nomodule',\r\n    'novalidate',\r\n    'open',\r\n    'playsinline',\r\n    'readonly',\r\n    'required',\r\n    'reversed',\r\n    'selected'\r\n];\r\n/**\r\n * List of HTML boolean attributes (e.g. `<input disabled>`).\r\n * Source: https://html.spec.whatwg.org/multipage/indices.html\r\n */\r\nconst boolean_attributes = new Set([..._boolean_attributes]);\r\n\r\n/** regex of all html void element names */\r\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\r\nfunction is_void(name) {\r\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\r\n}\r\n\r\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\r\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\r\n// https://infra.spec.whatwg.org/#noncharacter\r\nfunction spread(args, attrs_to_add) {\r\n    const attributes = Object.assign({}, ...args);\r\n    if (attrs_to_add) {\r\n        const classes_to_add = attrs_to_add.classes;\r\n        const styles_to_add = attrs_to_add.styles;\r\n        if (classes_to_add) {\r\n            if (attributes.class == null) {\r\n                attributes.class = classes_to_add;\r\n            }\r\n            else {\r\n                attributes.class += ' ' + classes_to_add;\r\n            }\r\n        }\r\n        if (styles_to_add) {\r\n            if (attributes.style == null) {\r\n                attributes.style = style_object_to_string(styles_to_add);\r\n            }\r\n            else {\r\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\r\n            }\r\n        }\r\n    }\r\n    let str = '';\r\n    Object.keys(attributes).forEach(name => {\r\n        if (invalid_attribute_name_character.test(name))\r\n            return;\r\n        const value = attributes[name];\r\n        if (value === true)\r\n            str += ' ' + name;\r\n        else if (boolean_attributes.has(name.toLowerCase())) {\r\n            if (value)\r\n                str += ' ' + name;\r\n        }\r\n        else if (value != null) {\r\n            str += ` ${name}=\"${value}\"`;\r\n        }\r\n    });\r\n    return str;\r\n}\r\nfunction merge_ssr_styles(style_attribute, style_directive) {\r\n    const style_object = {};\r\n    for (const individual_style of style_attribute.split(';')) {\r\n        const colon_index = individual_style.indexOf(':');\r\n        const name = individual_style.slice(0, colon_index).trim();\r\n        const value = individual_style.slice(colon_index + 1).trim();\r\n        if (!name)\r\n            continue;\r\n        style_object[name] = value;\r\n    }\r\n    for (const name in style_directive) {\r\n        const value = style_directive[name];\r\n        if (value) {\r\n            style_object[name] = value;\r\n        }\r\n        else {\r\n            delete style_object[name];\r\n        }\r\n    }\r\n    return style_object;\r\n}\r\nconst ATTR_REGEX = /[&\"]/g;\r\nconst CONTENT_REGEX = /[&<]/g;\r\n/**\r\n * Note: this method is performance sensitive and has been optimized\r\n * https://github.com/sveltejs/svelte/pull/5701\r\n */\r\nfunction escape(value, is_attr = false) {\r\n    const str = String(value);\r\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\r\n    pattern.lastIndex = 0;\r\n    let escaped = '';\r\n    let last = 0;\r\n    while (pattern.test(str)) {\r\n        const i = pattern.lastIndex - 1;\r\n        const ch = str[i];\r\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\r\n        last = i + 1;\r\n    }\r\n    return escaped + str.substring(last);\r\n}\r\nfunction escape_attribute_value(value) {\r\n    // keep booleans, null, and undefined for the sake of `spread`\r\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\r\n    return should_escape ? escape(value, true) : value;\r\n}\r\nfunction escape_object(obj) {\r\n    const result = {};\r\n    for (const key in obj) {\r\n        result[key] = escape_attribute_value(obj[key]);\r\n    }\r\n    return result;\r\n}\r\nfunction each(items, fn) {\r\n    let str = '';\r\n    for (let i = 0; i < items.length; i += 1) {\r\n        str += fn(items[i], i);\r\n    }\r\n    return str;\r\n}\r\nconst missing_component = {\r\n    $$render: () => ''\r\n};\r\nfunction validate_component(component, name) {\r\n    if (!component || !component.$$render) {\r\n        if (name === 'svelte:component')\r\n            name += ' this={...}';\r\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\r\n    }\r\n    return component;\r\n}\r\nfunction debug(file, line, column, values) {\r\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\r\n    console.log(values); // eslint-disable-line no-console\r\n    return '';\r\n}\r\nlet on_destroy;\r\nfunction create_ssr_component(fn) {\r\n    function $$render(result, props, bindings, slots, context) {\r\n        const parent_component = current_component;\r\n        const $$ = {\r\n            on_destroy,\r\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\r\n            // these will be immediately discarded\r\n            on_mount: [],\r\n            before_update: [],\r\n            after_update: [],\r\n            callbacks: blank_object()\r\n        };\r\n        set_current_component({ $$ });\r\n        const html = fn(result, props, bindings, slots);\r\n        set_current_component(parent_component);\r\n        return html;\r\n    }\r\n    return {\r\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\r\n            on_destroy = [];\r\n            const result = { title: '', head: '', css: new Set() };\r\n            const html = $$render(result, props, {}, $$slots, context);\r\n            run_all(on_destroy);\r\n            return {\r\n                html,\r\n                css: {\r\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\r\n                    map: null // TODO\r\n                },\r\n                head: result.title + result.head\r\n            };\r\n        },\r\n        $$render\r\n    };\r\n}\r\nfunction add_attribute(name, value, boolean) {\r\n    if (value == null || (boolean && !value))\r\n        return '';\r\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\r\n    return ` ${name}${assignment}`;\r\n}\r\nfunction add_classes(classes) {\r\n    return classes ? ` class=\"${classes}\"` : '';\r\n}\r\nfunction style_object_to_string(style_object) {\r\n    return Object.keys(style_object)\r\n        .filter(key => style_object[key])\r\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\r\n        .join(' ');\r\n}\r\nfunction add_styles(style_object) {\r\n    const styles = style_object_to_string(style_object);\r\n    return styles ? ` style=\"${styles}\"` : '';\r\n}\r\n\r\nfunction bind(component, name, callback) {\r\n    const index = component.$$.props[name];\r\n    if (index !== undefined) {\r\n        component.$$.bound[index] = callback;\r\n        callback(component.$$.ctx[index]);\r\n    }\r\n}\r\nfunction create_component(block) {\r\n    block && block.c();\r\n}\r\nfunction claim_component(block, parent_nodes) {\r\n    block && block.l(parent_nodes);\r\n}\r\nfunction mount_component(component, target, anchor, customElement) {\r\n    const { fragment, after_update } = component.$$;\r\n    fragment && fragment.m(target, anchor);\r\n    if (!customElement) {\r\n        // onMount happens before the initial afterUpdate\r\n        add_render_callback(() => {\r\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\r\n            // if the component was destroyed immediately\r\n            // it will update the `$$.on_destroy` reference to `null`.\r\n            // the destructured on_destroy may still reference to the old array\r\n            if (component.$$.on_destroy) {\r\n                component.$$.on_destroy.push(...new_on_destroy);\r\n            }\r\n            else {\r\n                // Edge case - component was destroyed immediately,\r\n                // most likely as a result of a binding initialising\r\n                run_all(new_on_destroy);\r\n            }\r\n            component.$$.on_mount = [];\r\n        });\r\n    }\r\n    after_update.forEach(add_render_callback);\r\n}\r\nfunction destroy_component(component, detaching) {\r\n    const $$ = component.$$;\r\n    if ($$.fragment !== null) {\r\n        flush_render_callbacks($$.after_update);\r\n        run_all($$.on_destroy);\r\n        $$.fragment && $$.fragment.d(detaching);\r\n        // TODO null out other refs, including component.$$ (but need to\r\n        // preserve final state?)\r\n        $$.on_destroy = $$.fragment = null;\r\n        $$.ctx = [];\r\n    }\r\n}\r\nfunction make_dirty(component, i) {\r\n    if (component.$$.dirty[0] === -1) {\r\n        dirty_components.push(component);\r\n        schedule_update();\r\n        component.$$.dirty.fill(0);\r\n    }\r\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\r\n}\r\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\r\n    const parent_component = current_component;\r\n    set_current_component(component);\r\n    const $$ = component.$$ = {\r\n        fragment: null,\r\n        ctx: [],\r\n        // state\r\n        props,\r\n        update: noop,\r\n        not_equal,\r\n        bound: blank_object(),\r\n        // lifecycle\r\n        on_mount: [],\r\n        on_destroy: [],\r\n        on_disconnect: [],\r\n        before_update: [],\r\n        after_update: [],\r\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\r\n        // everything else\r\n        callbacks: blank_object(),\r\n        dirty,\r\n        skip_bound: false,\r\n        root: options.target || parent_component.$$.root\r\n    };\r\n    append_styles && append_styles($$.root);\r\n    let ready = false;\r\n    $$.ctx = instance\r\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\r\n            const value = rest.length ? rest[0] : ret;\r\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\r\n                if (!$$.skip_bound && $$.bound[i])\r\n                    $$.bound[i](value);\r\n                if (ready)\r\n                    make_dirty(component, i);\r\n            }\r\n            return ret;\r\n        })\r\n        : [];\r\n    $$.update();\r\n    ready = true;\r\n    run_all($$.before_update);\r\n    // `false` as a special case of no DOM component\r\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\r\n    if (options.target) {\r\n        if (options.hydrate) {\r\n            start_hydrating();\r\n            const nodes = children(options.target);\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            $$.fragment && $$.fragment.l(nodes);\r\n            nodes.forEach(detach);\r\n        }\r\n        else {\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            $$.fragment && $$.fragment.c();\r\n        }\r\n        if (options.intro)\r\n            transition_in(component.$$.fragment);\r\n        mount_component(component, options.target, options.anchor, options.customElement);\r\n        end_hydrating();\r\n        flush();\r\n    }\r\n    set_current_component(parent_component);\r\n}\r\nlet SvelteElement;\r\nif (typeof HTMLElement === 'function') {\r\n    SvelteElement = class extends HTMLElement {\r\n        constructor() {\r\n            super();\r\n            this.attachShadow({ mode: 'open' });\r\n        }\r\n        connectedCallback() {\r\n            const { on_mount } = this.$$;\r\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\r\n            // @ts-ignore todo: improve typings\r\n            for (const key in this.$$.slotted) {\r\n                // @ts-ignore todo: improve typings\r\n                this.appendChild(this.$$.slotted[key]);\r\n            }\r\n        }\r\n        attributeChangedCallback(attr, _oldValue, newValue) {\r\n            this[attr] = newValue;\r\n        }\r\n        disconnectedCallback() {\r\n            run_all(this.$$.on_disconnect);\r\n        }\r\n        $destroy() {\r\n            destroy_component(this, 1);\r\n            this.$destroy = noop;\r\n        }\r\n        $on(type, callback) {\r\n            // TODO should this delegate to addEventListener?\r\n            if (!is_function(callback)) {\r\n                return noop;\r\n            }\r\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\r\n            callbacks.push(callback);\r\n            return () => {\r\n                const index = callbacks.indexOf(callback);\r\n                if (index !== -1)\r\n                    callbacks.splice(index, 1);\r\n            };\r\n        }\r\n        $set($$props) {\r\n            if (this.$$set && !is_empty($$props)) {\r\n                this.$$.skip_bound = true;\r\n                this.$$set($$props);\r\n                this.$$.skip_bound = false;\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * Base class for Svelte components. Used when dev=false.\r\n */\r\nclass SvelteComponent {\r\n    $destroy() {\r\n        destroy_component(this, 1);\r\n        this.$destroy = noop;\r\n    }\r\n    $on(type, callback) {\r\n        if (!is_function(callback)) {\r\n            return noop;\r\n        }\r\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\r\n        callbacks.push(callback);\r\n        return () => {\r\n            const index = callbacks.indexOf(callback);\r\n            if (index !== -1)\r\n                callbacks.splice(index, 1);\r\n        };\r\n    }\r\n    $set($$props) {\r\n        if (this.$$set && !is_empty($$props)) {\r\n            this.$$.skip_bound = true;\r\n            this.$$set($$props);\r\n            this.$$.skip_bound = false;\r\n        }\r\n    }\r\n}\r\n\r\nfunction dispatch_dev(type, detail) {\r\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.1' }, detail), { bubbles: true }));\r\n}\r\nfunction append_dev(target, node) {\r\n    dispatch_dev('SvelteDOMInsert', { target, node });\r\n    append(target, node);\r\n}\r\nfunction append_hydration_dev(target, node) {\r\n    dispatch_dev('SvelteDOMInsert', { target, node });\r\n    append_hydration(target, node);\r\n}\r\nfunction insert_dev(target, node, anchor) {\r\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\r\n    insert(target, node, anchor);\r\n}\r\nfunction insert_hydration_dev(target, node, anchor) {\r\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\r\n    insert_hydration(target, node, anchor);\r\n}\r\nfunction detach_dev(node) {\r\n    dispatch_dev('SvelteDOMRemove', { node });\r\n    detach(node);\r\n}\r\nfunction detach_between_dev(before, after) {\r\n    while (before.nextSibling && before.nextSibling !== after) {\r\n        detach_dev(before.nextSibling);\r\n    }\r\n}\r\nfunction detach_before_dev(after) {\r\n    while (after.previousSibling) {\r\n        detach_dev(after.previousSibling);\r\n    }\r\n}\r\nfunction detach_after_dev(before) {\r\n    while (before.nextSibling) {\r\n        detach_dev(before.nextSibling);\r\n    }\r\n}\r\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\r\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\r\n    if (has_prevent_default)\r\n        modifiers.push('preventDefault');\r\n    if (has_stop_propagation)\r\n        modifiers.push('stopPropagation');\r\n    if (has_stop_immediate_propagation)\r\n        modifiers.push('stopImmediatePropagation');\r\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\r\n    const dispose = listen(node, event, handler, options);\r\n    return () => {\r\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\r\n        dispose();\r\n    };\r\n}\r\nfunction attr_dev(node, attribute, value) {\r\n    attr(node, attribute, value);\r\n    if (value == null)\r\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\r\n    else\r\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\r\n}\r\nfunction prop_dev(node, property, value) {\r\n    node[property] = value;\r\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\r\n}\r\nfunction dataset_dev(node, property, value) {\r\n    node.dataset[property] = value;\r\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\r\n}\r\nfunction set_data_dev(text, data) {\r\n    data = '' + data;\r\n    if (text.data === data)\r\n        return;\r\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\r\n    text.data = data;\r\n}\r\nfunction set_data_contenteditable_dev(text, data) {\r\n    data = '' + data;\r\n    if (text.wholeText === data)\r\n        return;\r\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\r\n    text.data = data;\r\n}\r\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\r\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\r\n        set_data_contenteditable_dev(text, data);\r\n    }\r\n    else {\r\n        set_data_dev(text, data);\r\n    }\r\n}\r\nfunction validate_each_argument(arg) {\r\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\r\n        let msg = '{#each} only iterates over array-like objects.';\r\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\r\n            msg += ' You can use a spread to convert this iterable into an array.';\r\n        }\r\n        throw new Error(msg);\r\n    }\r\n}\r\nfunction validate_slots(name, slot, keys) {\r\n    for (const slot_key of Object.keys(slot)) {\r\n        if (!~keys.indexOf(slot_key)) {\r\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\r\n        }\r\n    }\r\n}\r\nfunction validate_dynamic_element(tag) {\r\n    const is_string = typeof tag === 'string';\r\n    if (tag && !is_string) {\r\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\r\n    }\r\n}\r\nfunction validate_void_dynamic_element(tag) {\r\n    if (tag && is_void(tag)) {\r\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\r\n    }\r\n}\r\nfunction construct_svelte_component_dev(component, props) {\r\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\r\n    try {\r\n        const instance = new component(props);\r\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\r\n            throw new Error(error_message);\r\n        }\r\n        return instance;\r\n    }\r\n    catch (err) {\r\n        const { message } = err;\r\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\r\n            throw new Error(error_message);\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\r\n */\r\nclass SvelteComponentDev extends SvelteComponent {\r\n    constructor(options) {\r\n        if (!options || (!options.target && !options.$$inline)) {\r\n            throw new Error(\"'target' is a required option\");\r\n        }\r\n        super();\r\n    }\r\n    $destroy() {\r\n        super.$destroy();\r\n        this.$destroy = () => {\r\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\r\n        };\r\n    }\r\n    $capture_state() { }\r\n    $inject_state() { }\r\n}\r\n/**\r\n * Base class to create strongly typed Svelte components.\r\n * This only exists for typing purposes and should be used in `.d.ts` files.\r\n *\r\n * ### Example:\r\n *\r\n * You have component library on npm called `component-library`, from which\r\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\r\n * you want to provide typings. Therefore you create a `index.d.ts`:\r\n * ```ts\r\n * import { SvelteComponentTyped } from \"svelte\";\r\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\r\n * ```\r\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\r\n * to provide intellisense and to use the component like this in a Svelte file\r\n * with TypeScript:\r\n * ```svelte\r\n * <script lang=\"ts\">\r\n * \timport { MyComponent } from \"component-library\";\r\n * </script>\r\n * <MyComponent foo={'bar'} />\r\n * ```\r\n *\r\n * #### Why not make this part of `SvelteComponent(Dev)`?\r\n * Because\r\n * ```ts\r\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\r\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\r\n * ```\r\n * will throw a type error, so we need to separate the more strictly typed class.\r\n */\r\nclass SvelteComponentTyped extends SvelteComponentDev {\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n}\r\nfunction loop_guard(timeout) {\r\n    const start = Date.now();\r\n    return () => {\r\n        if (Date.now() - start > timeout) {\r\n            throw new Error('Infinite loop detected');\r\n        }\r\n    };\r\n}\r\n\r\nexport { HtmlTag, HtmlTagHydration, ResizeObserverSingleton, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_iframe_resize_listener, add_location, add_render_callback, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, resize_observer_border_box, resize_observer_content_box, resize_observer_device_pixel_content_box, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\r\n","// Abstracted built-in Node.js Modules\r\n\r\n//@ts-ignore\r\nexport const crypto = (\r\n  typeof window.cep !== \"undefined\" ? require(\"crypto\") : {}\r\n) as typeof import(\"crypto\");\r\nexport const assert = (\r\n  typeof window.cep !== \"undefined\" ? require(\"assert\") : {}\r\n) as typeof import(\"assert\");\r\nexport const buffer = (\r\n  typeof window.cep !== \"undefined\" ? require(\"buffer\") : {}\r\n) as typeof import(\"buffer\");\r\nexport const child_process = (\r\n  typeof window.cep !== \"undefined\" ? require(\"child_process\") : {}\r\n) as typeof import(\"child_process\");\r\nexport const cluster = (\r\n  typeof window.cep !== \"undefined\" ? require(\"cluster\") : {}\r\n) as typeof import(\"cluster\");\r\nexport const dgram = (\r\n  typeof window.cep !== \"undefined\" ? require(\"dgram\") : {}\r\n) as typeof import(\"dgram\");\r\nexport const dns = (\r\n  typeof window.cep !== \"undefined\" ? require(\"dns\") : {}\r\n) as typeof import(\"dns\");\r\nexport const domain = (\r\n  typeof window.cep !== \"undefined\" ? require(\"domain\") : {}\r\n) as typeof import(\"domain\");\r\nexport const events = (\r\n  typeof window.cep !== \"undefined\" ? require(\"events\") : {}\r\n) as typeof import(\"events\");\r\nexport const fs = (\r\n  typeof window.cep !== \"undefined\" ? require(\"fs\") : {}\r\n) as typeof import(\"fs\");\r\nexport const http = (\r\n  typeof window.cep !== \"undefined\" ? require(\"http\") : {}\r\n) as typeof import(\"http\");\r\nexport const https = (\r\n  typeof window.cep !== \"undefined\" ? require(\"https\") : {}\r\n) as typeof import(\"https\");\r\nexport const net = (\r\n  typeof window.cep !== \"undefined\" ? require(\"net\") : {}\r\n) as typeof import(\"net\");\r\nexport const os = (\r\n  typeof window.cep !== \"undefined\" ? require(\"os\") : {}\r\n) as typeof import(\"os\");\r\nexport const path = (\r\n  typeof window.cep !== \"undefined\" ? require(\"path\") : {}\r\n) as typeof import(\"path\");\r\nexport const punycode = (\r\n  typeof window.cep !== \"undefined\" ? require(\"punycode\") : {}\r\n) as typeof import(\"punycode\");\r\nexport const querystring = (\r\n  typeof window.cep !== \"undefined\" ? require(\"querystring\") : {}\r\n) as typeof import(\"querystring\");\r\nexport const readline = (\r\n  typeof window.cep !== \"undefined\" ? require(\"readline\") : {}\r\n) as typeof import(\"readline\");\r\nexport const stream = (\r\n  typeof window.cep !== \"undefined\" ? require(\"stream\") : {}\r\n) as typeof import(\"stream\");\r\nexport const string_decoder = (\r\n  typeof window.cep !== \"undefined\" ? require(\"string_decoder\") : {}\r\n) as typeof import(\"string_decoder\");\r\nexport const timers = (\r\n  typeof window.cep !== \"undefined\" ? require(\"timers\") : {}\r\n) as typeof import(\"timers\");\r\nexport const tls = (\r\n  typeof window.cep !== \"undefined\" ? require(\"tls\") : {}\r\n) as typeof import(\"tls\");\r\nexport const tty = (\r\n  typeof window.cep !== \"undefined\" ? require(\"tty\") : {}\r\n) as typeof import(\"tty\");\r\nexport const url = (\r\n  typeof window.cep !== \"undefined\" ? require(\"url\") : {}\r\n) as typeof import(\"url\");\r\nexport const util = (\r\n  typeof window.cep !== \"undefined\" ? require(\"util\") : {}\r\n) as typeof import(\"util\");\r\nexport const v8 = (\r\n  typeof window.cep !== \"undefined\" ? require(\"v8\") : {}\r\n) as typeof import(\"v8\");\r\nexport const vm = (\r\n  typeof window.cep !== \"undefined\" ? require(\"vm\") : {}\r\n) as typeof import(\"vm\");\r\nexport const zlib = (\r\n  typeof window.cep !== \"undefined\" ? require(\"zlib\") : {}\r\n) as typeof import(\"zlib\");\r\n","/**************************************************************************************************\r\n *\r\n * ADOBE SYSTEMS INCORPORATED\r\n * Copyright 2020 Adobe Systems Incorporated\r\n * All Rights Reserved.\r\n *\r\n * NOTICE:  Adobe permits you to use, modify, and distribute this file in accordance with the\r\n * terms of the Adobe license agreement accompanying it.  If you have received this file from a\r\n * source other than Adobe, then your use, modification, or distribution of it requires the prior\r\n * written permission of Adobe.\r\n *\r\n **************************************************************************************************/\r\n\r\n/** CSInterface - v11.0.0 */\r\n\r\n/**\r\n * Stores constants for the window types supported by the CSXS infrastructure.\r\n */\r\nfunction CSXSWindowType() {}\r\n\r\n/** Constant for the CSXS window type Panel. */\r\nCSXSWindowType._PANEL = \"Panel\";\r\n\r\n/** Constant for the CSXS window type Modeless. */\r\nCSXSWindowType._MODELESS = \"Modeless\";\r\n\r\n/** Constant for the CSXS window type ModalDialog. */\r\nCSXSWindowType._MODAL_DIALOG = \"ModalDialog\";\r\n\r\n/** EvalScript error message */\r\nlet EvalScript_ErrMessage = \"EvalScript error.\";\r\n\r\n/**\r\n * @class Version\r\n * Defines a version number with major, minor, micro, and special\r\n * components. The major, minor and micro values are numeric; the special\r\n * value can be any string.\r\n *\r\n * @param major   The major version component, a positive integer up to nine digits long.\r\n * @param minor   The minor version component, a positive integer up to nine digits long.\r\n * @param micro   The micro version component, a positive integer up to nine digits long.\r\n * @param special The special version component, an arbitrary string.\r\n *\r\n * @return A new \\c Version object.\r\n */\r\nfunction Version(major, minor, micro, special) {\r\n  this.major = major;\r\n  this.minor = minor;\r\n  this.micro = micro;\r\n  this.special = special;\r\n}\r\n\r\n/**\r\n * The maximum value allowed for a numeric version component.\r\n * This reflects the maximum value allowed in PlugPlug and the manifest schema.\r\n */\r\nVersion.MAX_NUM = 999999999;\r\n\r\n/**\r\n * @class VersionBound\r\n * Defines a boundary for a version range, which associates a \\c Version object\r\n * with a flag for whether it is an inclusive or exclusive boundary.\r\n *\r\n * @param version   The \\c #Version object.\r\n * @param inclusive True if this boundary is inclusive, false if it is exclusive.\r\n *\r\n * @return A new \\c VersionBound object.\r\n */\r\nfunction VersionBound(version, inclusive) {\r\n  this.version = version;\r\n  this.inclusive = inclusive;\r\n}\r\n\r\n/**\r\n * @class VersionRange\r\n * Defines a range of versions using a lower boundary and optional upper boundary.\r\n *\r\n * @param lowerBound The \\c #VersionBound object.\r\n * @param upperBound The \\c #VersionBound object, or null for a range with no upper boundary.\r\n *\r\n * @return A new \\c VersionRange object.\r\n */\r\nfunction VersionRange(lowerBound, upperBound) {\r\n  this.lowerBound = lowerBound;\r\n  this.upperBound = upperBound;\r\n}\r\n\r\n/**\r\n * @class Runtime\r\n * Represents a runtime related to the CEP infrastructure.\r\n * Extensions can declare dependencies on particular\r\n * CEP runtime versions in the extension manifest.\r\n *\r\n * @param name    The runtime name.\r\n * @param version A \\c #VersionRange object that defines a range of valid versions.\r\n *\r\n * @return A new \\c Runtime object.\r\n */\r\nfunction Runtime(name, versionRange) {\r\n  this.name = name;\r\n  this.versionRange = versionRange;\r\n}\r\n\r\n/**\r\n * @class Extension\r\n * Encapsulates a CEP-based extension to an Adobe application.\r\n *\r\n * @param id              The unique identifier of this extension.\r\n * @param name            The localizable display name of this extension.\r\n * @param mainPath        The path of the \"index.html\" file.\r\n * @param basePath        The base path of this extension.\r\n * @param windowType          The window type of the main window of this extension.\r\n\t\t\t\t  Valid values are defined by \\c #CSXSWindowType.\r\n * @param width           The default width in pixels of the main window of this extension.\r\n * @param height          The default height in pixels of the main window of this extension.\r\n * @param minWidth        The minimum width in pixels of the main window of this extension.\r\n * @param minHeight       The minimum height in pixels of the main window of this extension.\r\n * @param maxWidth        The maximum width in pixels of the main window of this extension.\r\n * @param maxHeight       The maximum height in pixels of the main window of this extension.\r\n * @param defaultExtensionDataXml The extension data contained in the default \\c ExtensionDispatchInfo section of the extension manifest.\r\n * @param specialExtensionDataXml The extension data contained in the application-specific \\c ExtensionDispatchInfo section of the extension manifest.\r\n * @param requiredRuntimeList     An array of \\c Runtime objects for runtimes required by this extension.\r\n * @param isAutoVisible       True if this extension is visible on loading.\r\n * @param isPluginExtension   True if this extension has been deployed in the Plugins folder of the host application.\r\n *\r\n * @return A new \\c Extension object.\r\n */\r\nfunction Extension(\r\n  id,\r\n  name,\r\n  mainPath,\r\n  basePath,\r\n  windowType,\r\n  width,\r\n  height,\r\n  minWidth,\r\n  minHeight,\r\n  maxWidth,\r\n  maxHeight,\r\n  defaultExtensionDataXml,\r\n  specialExtensionDataXml,\r\n  requiredRuntimeList,\r\n  isAutoVisible,\r\n  isPluginExtension\r\n) {\r\n  this.id = id;\r\n  this.name = name;\r\n  this.mainPath = mainPath;\r\n  this.basePath = basePath;\r\n  this.windowType = windowType;\r\n  this.width = width;\r\n  this.height = height;\r\n  this.minWidth = minWidth;\r\n  this.minHeight = minHeight;\r\n  this.maxWidth = maxWidth;\r\n  this.maxHeight = maxHeight;\r\n  this.defaultExtensionDataXml = defaultExtensionDataXml;\r\n  this.specialExtensionDataXml = specialExtensionDataXml;\r\n  this.requiredRuntimeList = requiredRuntimeList;\r\n  this.isAutoVisible = isAutoVisible;\r\n  this.isPluginExtension = isPluginExtension;\r\n}\r\n\r\n/**\r\n * @class CSEvent\r\n * A standard JavaScript event, the base class for CEP events.\r\n *\r\n * @param type        The name of the event type.\r\n * @param scope       The scope of event, can be \"GLOBAL\" or \"APPLICATION\".\r\n * @param appId       The unique identifier of the application that generated the event.\r\n * @param extensionId     The unique identifier of the extension that generated the event.\r\n *\r\n * @return A new \\c CSEvent object\r\n */\r\nfunction CSEvent(type, scope, appId, extensionId) {\r\n  this.type = type;\r\n  this.scope = scope;\r\n  this.appId = appId;\r\n  this.extensionId = extensionId;\r\n}\r\n\r\n/** Event-specific data. */\r\nCSEvent.prototype.data = \"\";\r\n\r\n/**\r\n * @class SystemPath\r\n * Stores operating-system-specific location constants for use in the\r\n * \\c #CSInterface.getSystemPath() method.\r\n * @return A new \\c SystemPath object.\r\n */\r\nfunction SystemPath() {}\r\n\r\n/** The path to user data.  */\r\nSystemPath.USER_DATA = \"userData\";\r\n\r\n/** The path to common files for Adobe applications.  */\r\nSystemPath.COMMON_FILES = \"commonFiles\";\r\n\r\n/** The path to the user's default document folder.  */\r\nSystemPath.MY_DOCUMENTS = \"myDocuments\";\r\n\r\n/** @deprecated. Use \\c #SystemPath.Extension.  */\r\nSystemPath.APPLICATION = \"application\";\r\n\r\n/** The path to current extension.  */\r\nSystemPath.EXTENSION = \"extension\";\r\n\r\n/** The path to hosting application's executable.  */\r\nSystemPath.HOST_APPLICATION = \"hostApplication\";\r\n\r\n/**\r\n * @class ColorType\r\n * Stores color-type constants.\r\n */\r\nfunction ColorType() {}\r\n\r\n/** RGB color type. */\r\nColorType.RGB = \"rgb\";\r\n\r\n/** Gradient color type. */\r\nColorType.GRADIENT = \"gradient\";\r\n\r\n/** Null color type. */\r\nColorType.NONE = \"none\";\r\n\r\n/**\r\n * @class RGBColor\r\n * Stores an RGB color with red, green, blue, and alpha values.\r\n * All values are in the range [0.0 to 255.0]. Invalid numeric values are\r\n * converted to numbers within this range.\r\n *\r\n * @param red   The red value, in the range [0.0 to 255.0].\r\n * @param green The green value, in the range [0.0 to 255.0].\r\n * @param blue  The blue value, in the range [0.0 to 255.0].\r\n * @param alpha The alpha (transparency) value, in the range [0.0 to 255.0].\r\n *      The default, 255.0, means that the color is fully opaque.\r\n *\r\n * @return A new RGBColor object.\r\n */\r\nfunction RGBColor(red, green, blue, alpha) {\r\n  this.red = red;\r\n  this.green = green;\r\n  this.blue = blue;\r\n  this.alpha = alpha;\r\n}\r\n\r\n/**\r\n * @class Direction\r\n * A point value  in which the y component is 0 and the x component\r\n * is positive or negative for a right or left direction,\r\n * or the x component is 0 and the y component is positive or negative for\r\n * an up or down direction.\r\n *\r\n * @param x     The horizontal component of the point.\r\n * @param y     The vertical component of the point.\r\n *\r\n * @return A new \\c Direction object.\r\n */\r\nfunction Direction(x, y) {\r\n  this.x = x;\r\n  this.y = y;\r\n}\r\n\r\n/**\r\n * @class GradientStop\r\n * Stores gradient stop information.\r\n *\r\n * @param offset   The offset of the gradient stop, in the range [0.0 to 1.0].\r\n * @param rgbColor The color of the gradient at this point, an \\c #RGBColor object.\r\n *\r\n * @return GradientStop object.\r\n */\r\nfunction GradientStop(offset, rgbColor) {\r\n  this.offset = offset;\r\n  this.rgbColor = rgbColor;\r\n}\r\n\r\n/**\r\n  * @class GradientColor\r\n  * Stores gradient color information.\r\n  *\r\n  * @param type          The gradient type, must be \"linear\".\r\n  * @param direction     A \\c #Direction object for the direction of the gradient\r\n\t\t\t\t (up, down, right, or left).\r\n  * @param numStops          The number of stops in the gradient.\r\n  * @param gradientStopList  An array of \\c #GradientStop objects.\r\n  *\r\n  * @return A new \\c GradientColor object.\r\n  */\r\nfunction GradientColor(type, direction, numStops, arrGradientStop) {\r\n  this.type = type;\r\n  this.direction = direction;\r\n  this.numStops = numStops;\r\n  this.arrGradientStop = arrGradientStop;\r\n}\r\n\r\n/**\r\n  * @class UIColor\r\n  * Stores color information, including the type, anti-alias level, and specific color\r\n  * values in a color object of an appropriate type.\r\n  *\r\n  * @param type          The color type, 1 for \"rgb\" and 2 for \"gradient\".\r\n\t\t\t\t The supplied color object must correspond to this type.\r\n  * @param antialiasLevel    The anti-alias level constant.\r\n  * @param color         A \\c #RGBColor or \\c #GradientColor object containing specific color information.\r\n  *\r\n  * @return A new \\c UIColor object.\r\n  */\r\nfunction UIColor(type, antialiasLevel, color) {\r\n  this.type = type;\r\n  this.antialiasLevel = antialiasLevel;\r\n  this.color = color;\r\n}\r\n\r\n/**\r\n * @class AppSkinInfo\r\n * Stores window-skin properties, such as color and font. All color parameter values are \\c #UIColor objects except that systemHighlightColor is \\c #RGBColor object.\r\n *\r\n * @param baseFontFamily        The base font family of the application.\r\n * @param baseFontSize          The base font size of the application.\r\n * @param appBarBackgroundColor     The application bar background color.\r\n * @param panelBackgroundColor      The background color of the extension panel.\r\n * @param appBarBackgroundColorSRGB     The application bar background color, as sRGB.\r\n * @param panelBackgroundColorSRGB      The background color of the extension panel, as sRGB.\r\n * @param systemHighlightColor          The highlight color of the extension panel, if provided by the host application. Otherwise, the operating-system highlight color.\r\n *\r\n * @return AppSkinInfo object.\r\n */\r\nfunction AppSkinInfo(\r\n  baseFontFamily,\r\n  baseFontSize,\r\n  appBarBackgroundColor,\r\n  panelBackgroundColor,\r\n  appBarBackgroundColorSRGB,\r\n  panelBackgroundColorSRGB,\r\n  systemHighlightColor\r\n) {\r\n  this.baseFontFamily = baseFontFamily;\r\n  this.baseFontSize = baseFontSize;\r\n  this.appBarBackgroundColor = appBarBackgroundColor;\r\n  this.panelBackgroundColor = panelBackgroundColor;\r\n  this.appBarBackgroundColorSRGB = appBarBackgroundColorSRGB;\r\n  this.panelBackgroundColorSRGB = panelBackgroundColorSRGB;\r\n  this.systemHighlightColor = systemHighlightColor;\r\n}\r\n\r\n/**\r\n * @class HostEnvironment\r\n * Stores information about the environment in which the extension is loaded.\r\n *\r\n * @param appName   The application's name.\r\n * @param appVersion    The application's version.\r\n * @param appLocale The application's current license locale.\r\n * @param appUILocale   The application's current UI locale.\r\n * @param appId     The application's unique identifier.\r\n * @param isAppOnline  True if the application is currently online.\r\n * @param appSkinInfo   An \\c #AppSkinInfo object containing the application's default color and font styles.\r\n *\r\n * @return A new \\c HostEnvironment object.\r\n */\r\nfunction HostEnvironment(\r\n  appName,\r\n  appVersion,\r\n  appLocale,\r\n  appUILocale,\r\n  appId,\r\n  isAppOnline,\r\n  appSkinInfo\r\n) {\r\n  this.appName = appName;\r\n  this.appVersion = appVersion;\r\n  this.appLocale = appLocale;\r\n  this.appUILocale = appUILocale;\r\n  this.appId = appId;\r\n  this.isAppOnline = isAppOnline;\r\n  this.appSkinInfo = appSkinInfo;\r\n}\r\n\r\n/**\r\n * @class HostCapabilities\r\n * Stores information about the host capabilities.\r\n *\r\n * @param EXTENDED_PANEL_MENU True if the application supports panel menu.\r\n * @param EXTENDED_PANEL_ICONS True if the application supports panel icon.\r\n * @param DELEGATE_APE_ENGINE True if the application supports delegated APE engine.\r\n * @param SUPPORT_HTML_EXTENSIONS True if the application supports HTML extensions.\r\n * @param DISABLE_FLASH_EXTENSIONS True if the application disables FLASH extensions.\r\n *\r\n * @return A new \\c HostCapabilities object.\r\n */\r\nfunction HostCapabilities(\r\n  EXTENDED_PANEL_MENU,\r\n  EXTENDED_PANEL_ICONS,\r\n  DELEGATE_APE_ENGINE,\r\n  SUPPORT_HTML_EXTENSIONS,\r\n  DISABLE_FLASH_EXTENSIONS\r\n) {\r\n  this.EXTENDED_PANEL_MENU = EXTENDED_PANEL_MENU;\r\n  this.EXTENDED_PANEL_ICONS = EXTENDED_PANEL_ICONS;\r\n  this.DELEGATE_APE_ENGINE = DELEGATE_APE_ENGINE;\r\n  this.SUPPORT_HTML_EXTENSIONS = SUPPORT_HTML_EXTENSIONS;\r\n  this.DISABLE_FLASH_EXTENSIONS = DISABLE_FLASH_EXTENSIONS; // Since 5.0.0\r\n}\r\n\r\n/**\r\n * @class ApiVersion\r\n * Stores current api version.\r\n *\r\n * Since 4.2.0\r\n *\r\n * @param major  The major version\r\n * @param minor  The minor version.\r\n * @param micro  The micro version.\r\n *\r\n * @return ApiVersion object.\r\n */\r\nfunction ApiVersion(major, minor, micro) {\r\n  this.major = major;\r\n  this.minor = minor;\r\n  this.micro = micro;\r\n}\r\n\r\n/**\r\n * @class MenuItemStatus\r\n * Stores flyout menu item status\r\n *\r\n * Since 5.2.0\r\n *\r\n * @param menuItemLabel  The menu item label.\r\n * @param enabled        True if user wants to enable the menu item.\r\n * @param checked        True if user wants to check the menu item.\r\n *\r\n * @return MenuItemStatus object.\r\n */\r\nfunction MenuItemStatus(menuItemLabel, enabled, checked) {\r\n  this.menuItemLabel = menuItemLabel;\r\n  this.enabled = enabled;\r\n  this.checked = checked;\r\n}\r\n\r\n/**\r\n * @class ContextMenuItemStatus\r\n * Stores the status of the context menu item.\r\n *\r\n * Since 5.2.0\r\n *\r\n * @param menuItemID     The menu item id.\r\n * @param enabled        True if user wants to enable the menu item.\r\n * @param checked        True if user wants to check the menu item.\r\n *\r\n * @return MenuItemStatus object.\r\n */\r\nfunction ContextMenuItemStatus(menuItemID, enabled, checked) {\r\n  this.menuItemID = menuItemID;\r\n  this.enabled = enabled;\r\n  this.checked = checked;\r\n}\r\n//------------------------------ CSInterface ----------------------------------\r\n\r\n/**\r\n * @class CSInterface\r\n * This is the entry point to the CEP extensibility infrastructure.\r\n * Instantiate this object and use it to:\r\n * <ul>\r\n * <li>Access information about the host application in which an extension is running</li>\r\n * <li>Launch an extension</li>\r\n * <li>Register interest in event notifications, and dispatch events</li>\r\n * </ul>\r\n *\r\n * @return A new \\c CSInterface object\r\n */\r\nfunction CSInterface() {}\r\n\r\n/**\r\n * User can add this event listener to handle native application theme color changes.\r\n * Callback function gives extensions ability to fine-tune their theme color after the\r\n * global theme color has been changed.\r\n * The callback function should be like below:\r\n *\r\n * @example\r\n * // event is a CSEvent object, but user can ignore it.\r\n * function OnAppThemeColorChanged(event)\r\n * {\r\n *    // Should get a latest HostEnvironment object from application.\r\n *    var skinInfo = JSON.parse(window.__adobe_cep__.getHostEnvironment()).appSkinInfo;\r\n *    // Gets the style information such as color info from the skinInfo,\r\n *    // and redraw all UI controls of your extension according to the style info.\r\n * }\r\n */\r\nCSInterface.THEME_COLOR_CHANGED_EVENT =\r\n  \"com.adobe.csxs.events.ThemeColorChanged\";\r\n\r\n/** The host environment data object. */\r\nCSInterface.prototype.hostEnvironment = window.__adobe_cep__\r\n  ? JSON.parse(window.__adobe_cep__.getHostEnvironment())\r\n  : null;\r\n\r\n/** Retrieves information about the host environment in which the\r\n *  extension is currently running.\r\n *\r\n *   @return A \\c #HostEnvironment object.\r\n */\r\nCSInterface.prototype.getHostEnvironment = function () {\r\n  this.hostEnvironment = JSON.parse(window.__adobe_cep__.getHostEnvironment());\r\n  return this.hostEnvironment;\r\n};\r\n\r\n/** Loads binary file created which is located at url asynchronously\r\n *\r\n *@param urlName url at which binary file is located. Local files should start with 'file://'\r\n *@param callback Optional. A callback function that returns after binary is loaded\r\n *@example\r\n * To create JS binary use command ./cep_compiler test.js test.bin\r\n * To load JS binary asyncronously\r\n *   var CSLib = new CSInterface();\r\n *   CSLib.loadBinAsync(url, function () { });\r\n */\r\nCSInterface.prototype.loadBinAsync = function (urlName, callback) {\r\n  try {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.responseType = \"arraybuffer\"; // make response as ArrayBuffer\r\n    xhr.open(\"GET\", urlName, true);\r\n    xhr.onerror = function () {\r\n      console.log(\"Unable to load snapshot from given URL\");\r\n      return false;\r\n    };\r\n    xhr.send();\r\n    xhr.onload = () => {\r\n      window.__adobe_cep__.loadSnapshot(xhr.response);\r\n      if (typeof callback === \"function\") {\r\n        callback();\r\n      } else if (typeof callback !== \"undefined\") {\r\n        console.log(\"Provided callback is not a function\");\r\n      }\r\n    };\r\n  } catch (err) {\r\n    console.log(err);\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/** Loads binary file created synchronously\r\n *\r\n *@param pathName the local path at which binary file is located\r\n *@example\r\n * To create JS binary use command ./cep_compiler test.js test.bin\r\n * To load JS binary syncronously\r\n *   var CSLib = new CSInterface();\r\n *   CSLib.loadBinSync(path);\r\n */\r\nCSInterface.prototype.loadBinSync = function (pathName) {\r\n  try {\r\n    var OSVersion = this.getOSInformation();\r\n    if (pathName.startsWith(\"file://\")) {\r\n      if (OSVersion.indexOf(\"Windows\") >= 0) {\r\n        pathName = pathName.replace(\"file:///\", \"\");\r\n      } else if (OSVersion.indexOf(\"Mac\") >= 0) {\r\n        pathName = pathName.replace(\"file://\", \"\");\r\n      }\r\n      window.__adobe_cep__.loadSnapshot(pathName);\r\n      return true;\r\n    }\r\n  } catch (err) {\r\n    console.log(err);\r\n    return false;\r\n  }\r\n  //control should not come here\r\n  return false;\r\n};\r\n\r\n/** Closes this extension. */\r\nCSInterface.prototype.closeExtension = function () {\r\n  window.__adobe_cep__.closeExtension();\r\n};\r\n\r\n/**\r\n * Retrieves a path for which a constant is defined in the system.\r\n *\r\n * @param pathType The path-type constant defined in \\c #SystemPath ,\r\n *\r\n * @return The platform-specific system path string.\r\n */\r\nCSInterface.prototype.getSystemPath = function (pathType) {\r\n  var path = decodeURI(window.__adobe_cep__.getSystemPath(pathType));\r\n  var OSVersion = this.getOSInformation();\r\n  if (OSVersion.indexOf(\"Windows\") >= 0) {\r\n    path = path.replace(\"file:///\", \"\");\r\n  } else if (OSVersion.indexOf(\"Mac\") >= 0) {\r\n    path = path.replace(\"file://\", \"\");\r\n  }\r\n  return path;\r\n};\r\n\r\n/**\r\n * Evaluates a JavaScript script, which can use the JavaScript DOM\r\n * of the host application.\r\n *\r\n * @param script    The JavaScript script.\r\n * @param callback  Optional. A callback function that receives the result of execution.\r\n *          If execution fails, the callback function receives the error message \\c EvalScript_ErrMessage.\r\n */\r\nCSInterface.prototype.evalScript = function (script, callback) {\r\n  if (callback === null || callback === undefined) {\r\n    callback = function (result) {};\r\n  }\r\n  window.__adobe_cep__.evalScript(script, callback);\r\n};\r\n\r\n/**\r\n * Retrieves the unique identifier of the application.\r\n * in which the extension is currently running.\r\n *\r\n * @return The unique ID string.\r\n */\r\nCSInterface.prototype.getApplicationID = function () {\r\n  var appId = this.hostEnvironment.appId;\r\n  return appId;\r\n};\r\n\r\n/**\r\n * Retrieves host capability information for the application\r\n * in which the extension is currently running.\r\n *\r\n * @return A \\c #HostCapabilities object.\r\n */\r\nCSInterface.prototype.getHostCapabilities = function () {\r\n  var hostCapabilities = JSON.parse(window.__adobe_cep__.getHostCapabilities());\r\n  return hostCapabilities;\r\n};\r\n\r\n/**\r\n * Triggers a CEP event programmatically. Yoy can use it to dispatch\r\n * an event of a predefined type, or of a type you have defined.\r\n *\r\n * @param event A \\c CSEvent object.\r\n */\r\nCSInterface.prototype.dispatchEvent = function (event) {\r\n  if (typeof event.data == \"object\") {\r\n    event.data = JSON.stringify(event.data);\r\n  }\r\n\r\n  window.__adobe_cep__.dispatchEvent(event);\r\n};\r\n\r\n/**\r\n * Registers an interest in a CEP event of a particular type, and\r\n * assigns an event handler.\r\n * The event infrastructure notifies your extension when events of this type occur,\r\n * passing the event object to the registered handler function.\r\n *\r\n * @param type     The name of the event type of interest.\r\n * @param listener The JavaScript handler function or method.\r\n * @param obj      Optional, the object containing the handler method, if any.\r\n *         Default is null.\r\n */\r\nCSInterface.prototype.addEventListener = function (type, listener, obj) {\r\n  window.__adobe_cep__.addEventListener(type, listener, obj);\r\n};\r\n\r\n/**\r\n * Removes a registered event listener.\r\n *\r\n * @param type      The name of the event type of interest.\r\n * @param listener  The JavaScript handler function or method that was registered.\r\n * @param obj       Optional, the object containing the handler method, if any.\r\n *          Default is null.\r\n */\r\nCSInterface.prototype.removeEventListener = function (type, listener, obj) {\r\n  window.__adobe_cep__.removeEventListener(type, listener, obj);\r\n};\r\n\r\n/**\r\n * Loads and launches another extension, or activates the extension if it is already loaded.\r\n *\r\n * @param extensionId       The extension's unique identifier.\r\n * @param startupParams     Not currently used, pass \"\".\r\n *\r\n * @example\r\n * To launch the extension \"help\" with ID \"HLP\" from this extension, call:\r\n * <code>requestOpenExtension(\"HLP\", \"\"); </code>\r\n *\r\n */\r\nCSInterface.prototype.requestOpenExtension = function (extensionId, params) {\r\n  window.__adobe_cep__.requestOpenExtension(extensionId, params);\r\n};\r\n\r\n/**\r\n * Retrieves the list of extensions currently loaded in the current host application.\r\n * The extension list is initialized once, and remains the same during the lifetime\r\n * of the CEP session.\r\n *\r\n * @param extensionIds  Optional, an array of unique identifiers for extensions of interest.\r\n *          If omitted, retrieves data for all extensions.\r\n *\r\n * @return Zero or more \\c #Extension objects.\r\n */\r\nCSInterface.prototype.getExtensions = function (extensionIds) {\r\n  var extensionIdsStr = JSON.stringify(extensionIds);\r\n  var extensionsStr = window.__adobe_cep__.getExtensions(extensionIdsStr);\r\n\r\n  var extensions = JSON.parse(extensionsStr);\r\n  return extensions;\r\n};\r\n\r\n/**\r\n * Retrieves network-related preferences.\r\n *\r\n * @return A JavaScript object containing network preferences.\r\n */\r\nCSInterface.prototype.getNetworkPreferences = function () {\r\n  var result = window.__adobe_cep__.getNetworkPreferences();\r\n  var networkPre = JSON.parse(result);\r\n\r\n  return networkPre;\r\n};\r\n\r\n/**\r\n * Initializes the resource bundle for this extension with property values\r\n * for the current application and locale.\r\n * To support multiple locales, you must define a property file for each locale,\r\n * containing keyed display-string values for that locale.\r\n * See localization documentation for Extension Builder and related products.\r\n *\r\n * Keys can be in the\r\n * form <code>key.value=\"localized string\"</code>, for use in HTML text elements.\r\n * For example, in this input element, the localized \\c key.value string is displayed\r\n * instead of the empty \\c value string:\r\n *\r\n * <code><input type=\"submit\" value=\"\" data-locale=\"key\"/></code>\r\n *\r\n * @return An object containing the resource bundle information.\r\n */\r\nCSInterface.prototype.initResourceBundle = function () {\r\n  var resourceBundle = JSON.parse(window.__adobe_cep__.initResourceBundle());\r\n  var resElms = document.querySelectorAll(\"[data-locale]\");\r\n  for (var n = 0; n < resElms.length; n++) {\r\n    var resEl = resElms[n];\r\n    // Get the resource key from the element.\r\n    var resKey = resEl.getAttribute(\"data-locale\");\r\n    if (resKey) {\r\n      // Get all the resources that start with the key.\r\n      for (var key in resourceBundle) {\r\n        if (key.indexOf(resKey) === 0) {\r\n          var resValue = resourceBundle[key];\r\n          if (key.length == resKey.length) {\r\n            resEl.innerHTML = resValue;\r\n          } else if (\".\" == key.charAt(resKey.length)) {\r\n            var attrKey = key.substring(resKey.length + 1);\r\n            resEl[attrKey] = resValue;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return resourceBundle;\r\n};\r\n\r\n/**\r\n * Writes installation information to a file.\r\n *\r\n * @return The file path.\r\n */\r\nCSInterface.prototype.dumpInstallationInfo = function () {\r\n  return window.__adobe_cep__.dumpInstallationInfo();\r\n};\r\n\r\n/**\r\n * Retrieves version information for the current Operating System,\r\n * See http://www.useragentstring.com/pages/Chrome/ for Chrome \\c navigator.userAgent values.\r\n *\r\n * @return A string containing the OS version, or \"unknown Operation System\".\r\n * If user customizes the User Agent by setting CEF command parameter \"--user-agent\", only\r\n * \"Mac OS X\" or \"Windows\" will be returned.\r\n */\r\nCSInterface.prototype.getOSInformation = function () {\r\n  var userAgent = navigator.userAgent;\r\n\r\n  if (navigator.platform == \"Win32\" || navigator.platform == \"Windows\") {\r\n    var winVersion = \"Windows\";\r\n    var winBit = \"\";\r\n    if (userAgent.indexOf(\"Windows\") > -1) {\r\n      if (userAgent.indexOf(\"Windows NT 5.0\") > -1) {\r\n        winVersion = \"Windows 2000\";\r\n      } else if (userAgent.indexOf(\"Windows NT 5.1\") > -1) {\r\n        winVersion = \"Windows XP\";\r\n      } else if (userAgent.indexOf(\"Windows NT 5.2\") > -1) {\r\n        winVersion = \"Windows Server 2003\";\r\n      } else if (userAgent.indexOf(\"Windows NT 6.0\") > -1) {\r\n        winVersion = \"Windows Vista\";\r\n      } else if (userAgent.indexOf(\"Windows NT 6.1\") > -1) {\r\n        winVersion = \"Windows 7\";\r\n      } else if (userAgent.indexOf(\"Windows NT 6.2\") > -1) {\r\n        winVersion = \"Windows 8\";\r\n      } else if (userAgent.indexOf(\"Windows NT 6.3\") > -1) {\r\n        winVersion = \"Windows 8.1\";\r\n      } else if (userAgent.indexOf(\"Windows NT 10\") > -1) {\r\n        winVersion = \"Windows 10\";\r\n      }\r\n\r\n      if (userAgent.indexOf(\"WOW64\") > -1 || userAgent.indexOf(\"Win64\") > -1) {\r\n        winBit = \" 64-bit\";\r\n      } else {\r\n        winBit = \" 32-bit\";\r\n      }\r\n    }\r\n\r\n    return winVersion + winBit;\r\n  } else if (\r\n    navigator.platform == \"MacIntel\" ||\r\n    navigator.platform == \"Macintosh\"\r\n  ) {\r\n    var result = \"Mac OS X\";\r\n\r\n    if (userAgent.indexOf(\"Mac OS X\") > -1) {\r\n      result = userAgent.substring(\r\n        userAgent.indexOf(\"Mac OS X\"),\r\n        userAgent.indexOf(\")\")\r\n      );\r\n      result = result.replace(/_/g, \".\");\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  return \"Unknown Operation System\";\r\n};\r\n\r\n/**\r\n * Opens a page in the default system browser.\r\n *\r\n * Since 4.2.0\r\n *\r\n * @param url  The URL of the page/file to open, or the email address.\r\n * Must use HTTP/HTTPS/file/mailto protocol. For example:\r\n *   \"http://www.adobe.com\"\r\n *   \"https://github.com\"\r\n *   \"file:///C:/log.txt\"\r\n *   \"mailto:test@adobe.com\"\r\n *\r\n * @return One of these error codes:\\n\r\n *      <ul>\\n\r\n *          <li>NO_ERROR - 0</li>\\n\r\n *          <li>ERR_UNKNOWN - 1</li>\\n\r\n *          <li>ERR_INVALID_PARAMS - 2</li>\\n\r\n *          <li>ERR_INVALID_URL - 201</li>\\n\r\n *      </ul>\\n\r\n */\r\nCSInterface.prototype.openURLInDefaultBrowser = function (url) {\r\n  return cep.util.openURLInDefaultBrowser(url);\r\n};\r\n\r\n/**\r\n * Retrieves extension ID.\r\n *\r\n * Since 4.2.0\r\n *\r\n * @return extension ID.\r\n */\r\nCSInterface.prototype.getExtensionID = function () {\r\n  return window.__adobe_cep__.getExtensionId();\r\n};\r\n\r\n/**\r\n * Retrieves the scale factor of screen.\r\n * On Windows platform, the value of scale factor might be different from operating system's scale factor,\r\n * since host application may use its self-defined scale factor.\r\n *\r\n * Since 4.2.0\r\n *\r\n * @return One of the following float number.\r\n *      <ul>\\n\r\n *          <li> -1.0 when error occurs </li>\\n\r\n *          <li> 1.0 means normal screen </li>\\n\r\n *          <li> >1.0 means HiDPI screen </li>\\n\r\n *      </ul>\\n\r\n */\r\nCSInterface.prototype.getScaleFactor = function () {\r\n  return window.__adobe_cep__.getScaleFactor();\r\n};\r\n\r\n/**\r\n * Retrieves the scale factor of Monitor.\r\n *\r\n * Since 8.5.0\r\n *\r\n * @return value >= 1.0f\r\n * only available for windows machine\r\n */\r\nif (navigator.appVersion.toLowerCase().indexOf(\"windows\") >= 0) {\r\n  CSInterface.prototype.getMonitorScaleFactor = function () {\r\n    return window.__adobe_cep__.getMonitorScaleFactor();\r\n  };\r\n}\r\n\r\n/**\r\n * Set a handler to detect any changes of scale factor. This only works on Mac.\r\n *\r\n * Since 4.2.0\r\n *\r\n * @param handler   The function to be called when scale factor is changed.\r\n *\r\n */\r\nCSInterface.prototype.setScaleFactorChangedHandler = function (handler) {\r\n  window.__adobe_cep__.setScaleFactorChangedHandler(handler);\r\n};\r\n\r\n/**\r\n * Retrieves current API version.\r\n *\r\n * Since 4.2.0\r\n *\r\n * @return ApiVersion object.\r\n *\r\n */\r\nCSInterface.prototype.getCurrentApiVersion = function () {\r\n  var apiVersion = JSON.parse(window.__adobe_cep__.getCurrentApiVersion());\r\n  return apiVersion;\r\n};\r\n\r\n/**\r\n * Set panel flyout menu by an XML.\r\n *\r\n * Since 5.2.0\r\n *\r\n * Register a callback function for \"com.adobe.csxs.events.flyoutMenuClicked\" to get notified when a\r\n * menu item is clicked.\r\n * The \"data\" attribute of event is an object which contains \"menuId\" and \"menuName\" attributes.\r\n *\r\n * Register callback functions for \"com.adobe.csxs.events.flyoutMenuOpened\" and \"com.adobe.csxs.events.flyoutMenuClosed\"\r\n * respectively to get notified when flyout menu is opened or closed.\r\n *\r\n * @param menu     A XML string which describes menu structure.\r\n * An example menu XML:\r\n * <Menu>\r\n *   <MenuItem Id=\"menuItemId1\" Label=\"TestExample1\" Enabled=\"true\" Checked=\"false\"/>\r\n *   <MenuItem Label=\"TestExample2\">\r\n *     <MenuItem Label=\"TestExample2-1\" >\r\n *       <MenuItem Label=\"TestExample2-1-1\" Enabled=\"false\" Checked=\"true\"/>\r\n *     </MenuItem>\r\n *     <MenuItem Label=\"TestExample2-2\" Enabled=\"true\" Checked=\"true\"/>\r\n *   </MenuItem>\r\n *   <MenuItem Label=\"---\" />\r\n *   <MenuItem Label=\"TestExample3\" Enabled=\"false\" Checked=\"false\"/>\r\n * </Menu>\r\n *\r\n */\r\nCSInterface.prototype.setPanelFlyoutMenu = function (menu) {\r\n  if (\"string\" != typeof menu) {\r\n    return;\r\n  }\r\n\r\n  window.__adobe_cep__.invokeSync(\"setPanelFlyoutMenu\", menu);\r\n};\r\n\r\n/**\r\n * Updates a menu item in the extension window's flyout menu, by setting the enabled\r\n * and selection status.\r\n *\r\n * Since 5.2.0\r\n *\r\n * @param menuItemLabel The menu item label.\r\n * @param enabled       True to enable the item, false to disable it (gray it out).\r\n * @param checked       True to select the item, false to deselect it.\r\n *\r\n * @return false when the host application does not support this functionality (HostCapabilities.EXTENDED_PANEL_MENU is false).\r\n *         Fails silently if menu label is invalid.\r\n *\r\n * @see HostCapabilities.EXTENDED_PANEL_MENU\r\n */\r\nCSInterface.prototype.updatePanelMenuItem = function (\r\n  menuItemLabel,\r\n  enabled,\r\n  checked\r\n) {\r\n  var ret = false;\r\n  if (this.getHostCapabilities().EXTENDED_PANEL_MENU) {\r\n    var itemStatus = new MenuItemStatus(menuItemLabel, enabled, checked);\r\n    ret = window.__adobe_cep__.invokeSync(\r\n      \"updatePanelMenuItem\",\r\n      JSON.stringify(itemStatus)\r\n    );\r\n  }\r\n  return ret;\r\n};\r\n\r\n/**\r\n  * Set context menu by XML string.\r\n  *\r\n  * Since 5.2.0\r\n  *\r\n  * There are a number of conventions used to communicate what type of menu item to create and how it should be handled.\r\n  * - an item without menu ID or menu name is disabled and is not shown.\r\n  * - if the item name is \"---\" (three hyphens) then it is treated as a separator. The menu ID in this case will always be NULL.\r\n  * - Checkable attribute takes precedence over Checked attribute.\r\n  * - a PNG icon. For optimal display results please supply a 16 x 16px icon as larger dimensions will increase the size of the menu item.\r\n\t  The Chrome extension contextMenus API was taken as a reference.\r\n\t  https://developer.chrome.com/extensions/contextMenus\r\n  * - the items with icons and checkable items cannot coexist on the same menu level. The former take precedences over the latter.\r\n  *\r\n  * @param menu      A XML string which describes menu structure.\r\n  * @param callback  The callback function which is called when a menu item is clicked. The only parameter is the returned ID of clicked menu item.\r\n  *\r\n  * @description An example menu XML:\r\n  * <Menu>\r\n  *   <MenuItem Id=\"menuItemId1\" Label=\"TestExample1\" Enabled=\"true\" Checkable=\"true\" Checked=\"false\" Icon=\"./image/small_16X16.png\"/>\r\n  *   <MenuItem Id=\"menuItemId2\" Label=\"TestExample2\">\r\n  *     <MenuItem Id=\"menuItemId2-1\" Label=\"TestExample2-1\" >\r\n  *       <MenuItem Id=\"menuItemId2-1-1\" Label=\"TestExample2-1-1\" Enabled=\"false\" Checkable=\"true\" Checked=\"true\"/>\r\n  *     </MenuItem>\r\n  *     <MenuItem Id=\"menuItemId2-2\" Label=\"TestExample2-2\" Enabled=\"true\" Checkable=\"true\" Checked=\"true\"/>\r\n  *   </MenuItem>\r\n  *   <MenuItem Label=\"---\" />\r\n  *   <MenuItem Id=\"menuItemId3\" Label=\"TestExample3\" Enabled=\"false\" Checkable=\"true\" Checked=\"false\"/>\r\n  * </Menu>\r\n  */\r\nCSInterface.prototype.setContextMenu = function (menu, callback) {\r\n  if (\"string\" != typeof menu) {\r\n    return;\r\n  }\r\n\r\n  window.__adobe_cep__.invokeAsync(\"setContextMenu\", menu, callback);\r\n};\r\n\r\n/**\r\n  * Set context menu by JSON string.\r\n  *\r\n  * Since 6.0.0\r\n  *\r\n  * There are a number of conventions used to communicate what type of menu item to create and how it should be handled.\r\n  * - an item without menu ID or menu name is disabled and is not shown.\r\n  * - if the item label is \"---\" (three hyphens) then it is treated as a separator. The menu ID in this case will always be NULL.\r\n  * - Checkable attribute takes precedence over Checked attribute.\r\n  * - a PNG icon. For optimal display results please supply a 16 x 16px icon as larger dimensions will increase the size of the menu item.\r\n\t  The Chrome extension contextMenus API was taken as a reference.\r\n  * - the items with icons and checkable items cannot coexist on the same menu level. The former take precedences over the latter.\r\n\t  https://developer.chrome.com/extensions/contextMenus\r\n  *\r\n  * @param menu      A JSON string which describes menu structure.\r\n  * @param callback  The callback function which is called when a menu item is clicked. The only parameter is the returned ID of clicked menu item.\r\n  *\r\n  * @description An example menu JSON:\r\n  *\r\n  * {\r\n  *      \"menu\": [\r\n  *          {\r\n  *              \"id\": \"menuItemId1\",\r\n  *              \"label\": \"testExample1\",\r\n  *              \"enabled\": true,\r\n  *              \"checkable\": true,\r\n  *              \"checked\": false,\r\n  *              \"icon\": \"./image/small_16X16.png\"\r\n  *          },\r\n  *          {\r\n  *              \"id\": \"menuItemId2\",\r\n  *              \"label\": \"testExample2\",\r\n  *              \"menu\": [\r\n  *                  {\r\n  *                      \"id\": \"menuItemId2-1\",\r\n  *                      \"label\": \"testExample2-1\",\r\n  *                      \"menu\": [\r\n  *                          {\r\n  *                              \"id\": \"menuItemId2-1-1\",\r\n  *                              \"label\": \"testExample2-1-1\",\r\n  *                              \"enabled\": false,\r\n  *                              \"checkable\": true,\r\n  *                              \"checked\": true\r\n  *                          }\r\n  *                      ]\r\n  *                  },\r\n  *                  {\r\n  *                      \"id\": \"menuItemId2-2\",\r\n  *                      \"label\": \"testExample2-2\",\r\n  *                      \"enabled\": true,\r\n  *                      \"checkable\": true,\r\n  *                      \"checked\": true\r\n  *                  }\r\n  *              ]\r\n  *          },\r\n  *          {\r\n  *              \"label\": \"---\"\r\n  *          },\r\n  *          {\r\n  *              \"id\": \"menuItemId3\",\r\n  *              \"label\": \"testExample3\",\r\n  *              \"enabled\": false,\r\n  *              \"checkable\": true,\r\n  *              \"checked\": false\r\n  *          }\r\n  *      ]\r\n  *  }\r\n  *\r\n  */\r\nCSInterface.prototype.setContextMenuByJSON = function (menu, callback) {\r\n  if (\"string\" != typeof menu) {\r\n    return;\r\n  }\r\n\r\n  window.__adobe_cep__.invokeAsync(\"setContextMenuByJSON\", menu, callback);\r\n};\r\n\r\n/**\r\n * Updates a context menu item by setting the enabled and selection status.\r\n *\r\n * Since 5.2.0\r\n *\r\n * @param menuItemID    The menu item ID.\r\n * @param enabled       True to enable the item, false to disable it (gray it out).\r\n * @param checked       True to select the item, false to deselect it.\r\n */\r\nCSInterface.prototype.updateContextMenuItem = function (\r\n  menuItemID,\r\n  enabled,\r\n  checked\r\n) {\r\n  var itemStatus = new ContextMenuItemStatus(menuItemID, enabled, checked);\r\n  ret = window.__adobe_cep__.invokeSync(\r\n    \"updateContextMenuItem\",\r\n    JSON.stringify(itemStatus)\r\n  );\r\n};\r\n\r\n/**\r\n * Get the visibility status of an extension window.\r\n *\r\n * Since 6.0.0\r\n *\r\n * @return true if the extension window is visible; false if the extension window is hidden.\r\n */\r\nCSInterface.prototype.isWindowVisible = function () {\r\n  return window.__adobe_cep__.invokeSync(\"isWindowVisible\", \"\");\r\n};\r\n\r\n/**\r\n * Resize extension's content to the specified dimensions.\r\n * 1. Works with modal and modeless extensions in all Adobe products.\r\n * 2. Extension's manifest min/max size constraints apply and take precedence.\r\n * 3. For panel extensions\r\n *    3.1 This works in all Adobe products except:\r\n *        * Premiere Pro\r\n *        * Prelude\r\n *        * After Effects\r\n *    3.2 When the panel is in certain states (especially when being docked),\r\n *        it will not change to the desired dimensions even when the\r\n *        specified size satisfies min/max constraints.\r\n *\r\n * Since 6.0.0\r\n *\r\n * @param width  The new width\r\n * @param height The new height\r\n */\r\nCSInterface.prototype.resizeContent = function (width, height) {\r\n  window.__adobe_cep__.resizeContent(width, height);\r\n};\r\n\r\n/**\r\n * Register the invalid certificate callback for an extension.\r\n * This callback will be triggered when the extension tries to access the web site that contains the invalid certificate on the main frame.\r\n * But if the extension does not call this function and tries to access the web site containing the invalid certificate, a default error page will be shown.\r\n *\r\n * Since 6.1.0\r\n *\r\n * @param callback the callback function\r\n */\r\nCSInterface.prototype.registerInvalidCertificateCallback = function (callback) {\r\n  return window.__adobe_cep__.registerInvalidCertificateCallback(callback);\r\n};\r\n\r\n/**\r\n  * Register an interest in some key events to prevent them from being sent to the host application.\r\n  *\r\n  * This function works with modeless extensions and panel extensions.\r\n  * Generally all the key events will be sent to the host application for these two extensions if the current focused element\r\n  * is not text input or dropdown,\r\n  * If you want to intercept some key events and want them to be handled in the extension, please call this function\r\n  * in advance to prevent them being sent to the host application.\r\n  *\r\n  * Since 6.1.0\r\n  *\r\n  * @param keyEventsInterest      A JSON string describing those key events you are interested in. A null object or\r\n\t\t\t\t\t\t\t\t  an empty string will lead to removing the interest\r\n  *\r\n  * This JSON string should be an array, each object has following keys:\r\n  *\r\n  * keyCode:  [Required] represents an OS system dependent virtual key code identifying\r\n  *           the unmodified value of the pressed key.\r\n  * ctrlKey:  [optional] a Boolean that indicates if the control key was pressed (true) or not (false) when the event occurred.\r\n  * altKey:   [optional] a Boolean that indicates if the alt key was pressed (true) or not (false) when the event occurred.\r\n  * shiftKey: [optional] a Boolean that indicates if the shift key was pressed (true) or not (false) when the event occurred.\r\n  * metaKey:  [optional] (Mac Only) a Boolean that indicates if the Meta key was pressed (true) or not (false) when the event occurred.\r\n  *                      On Macintosh keyboards, this is the command key. To detect Windows key on Windows, please use keyCode instead.\r\n  * An example JSON string:\r\n  *\r\n  * [\r\n  *     {\r\n  *         \"keyCode\": 48\r\n  *     },\r\n  *     {\r\n  *         \"keyCode\": 123,\r\n  *         \"ctrlKey\": true\r\n  *     },\r\n  *     {\r\n  *         \"keyCode\": 123,\r\n  *         \"ctrlKey\": true,\r\n  *         \"metaKey\": true\r\n  *     }\r\n  * ]\r\n  *\r\n  */\r\nCSInterface.prototype.registerKeyEventsInterest = function (keyEventsInterest) {\r\n  return window.__adobe_cep__.registerKeyEventsInterest(keyEventsInterest);\r\n};\r\n\r\n/**\r\n * Set the title of the extension window.\r\n * This function works with modal and modeless extensions in all Adobe products, and panel extensions in Photoshop, InDesign, InCopy, Illustrator, Flash Pro and Dreamweaver.\r\n *\r\n * Since 6.1.0\r\n *\r\n * @param title The window title.\r\n */\r\nCSInterface.prototype.setWindowTitle = function (title) {\r\n  window.__adobe_cep__.invokeSync(\"setWindowTitle\", title);\r\n};\r\n\r\n/**\r\n * Get the title of the extension window.\r\n * This function works with modal and modeless extensions in all Adobe products, and panel extensions in Photoshop, InDesign, InCopy, Illustrator, Flash Pro and Dreamweaver.\r\n *\r\n * Since 6.1.0\r\n *\r\n * @return The window title.\r\n */\r\nCSInterface.prototype.getWindowTitle = function () {\r\n  return window.__adobe_cep__.invokeSync(\"getWindowTitle\", \"\");\r\n};\r\n\r\n// Boilerplate Added Export\r\nexport default CSInterface;\r\nexport {\r\n  CSXSWindowType,\r\n  Version,\r\n  VersionBound,\r\n  VersionRange,\r\n  Runtime,\r\n  Extension,\r\n  CSEvent,\r\n  SystemPath,\r\n  ColorType,\r\n  RGBColor,\r\n  Direction,\r\n  GradientStop,\r\n  GradientColor,\r\n  UIColor,\r\n  AppSkinInfo,\r\n  HostEnvironment,\r\n  HostCapabilities,\r\n  ApiVersion,\r\n  MenuItemStatus,\r\n  ContextMenuItemStatus,\r\n  CSInterface,\r\n};\r\n","/**************************************************************************************************\r\n *\r\n * ADOBE SYSTEMS INCORPORATED\r\n * Copyright 2020 Adobe Systems Incorporated\r\n * All Rights Reserved.\r\n *\r\n * NOTICE:  Adobe permits you to use, modify, and distribute this file in accordance with the\r\n * terms of the Adobe license agreement accompanying it.  If you have received this file from a\r\n * source other than Adobe, then your use, modification, or distribution of it requires the prior\r\n * written permission of Adobe.\r\n *\r\n **************************************************************************************************/\r\n\r\n/** Vulcan - v11.2.0 */\r\n\r\n/**\r\n * @class Vulcan\r\n *\r\n * The singleton instance, <tt>VulcanInterface</tt>, provides an interface\r\n * to the Vulcan. Allows you to launch CC applications\r\n * and discover information about them.\r\n */\r\nfunction Vulcan() {}\r\n\r\n/**\r\n * Gets all available application SAPCode-Specifiers on the local machine.\r\n *\r\n * Vulcan Control New 6.x APIs, and Deprecating older Vulcan Control APIs.\r\n * Changes : New getTargetSpecifiersEx returns productSAPCodeSpecifiers\r\n *\r\n * @return The array of all available application SAPCode-Specifiers.\r\n */\r\nVulcan.prototype.getTargetSpecifiersEx = function () {\r\n  var params = {};\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\r\n      \"vulcanGetTargetSpecifiersEx\",\r\n      JSON.stringify(params)\r\n    )\r\n  );\r\n};\r\n\r\n/**\r\n * Launches a CC application on the local machine, if it is not already running.\r\n *\r\n * Vulcan Control New 6.x APIs, and Deprecating older Vulcan Control APIs.\r\n * Changes : New launchAppEx uses productSAPCodeSpecifiers\r\n *\r\n * @param productSAPCodeSpecifier The application specifier; for example \"ILST-25.2.3\", \"ILST-25\", \"ILST-25.2.3-en_US\" and \"ILST. Refer to `Documentation/CEP 11.1 HTML Extension Cookbook.md#applications-integrated-with-cep` for product SAPCode.\r\n * @param focus           True to launch in foreground, or false to launch in the background.\r\n * @param cmdLine         Optional, command-line parameters to supply to the launch command.\r\n * @return True if the app can be launched, false otherwise.\r\n */\r\nVulcan.prototype.launchAppEx = function (\r\n  productSAPCodeSpecifier,\r\n  focus,\r\n  cmdLine\r\n) {\r\n  if (!requiredParamsValid(productSAPCodeSpecifier)) {\r\n    return false;\r\n  }\r\n\r\n  var params = {};\r\n  params.productSAPCodeSpecifier = productSAPCodeSpecifier;\r\n  params.focus = focus ? \"true\" : \"false\";\r\n  params.cmdLine = requiredParamsValid(cmdLine) ? cmdLine : \"\";\r\n\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\"vulcanLaunchAppEx\", JSON.stringify(params))\r\n  ).result;\r\n};\r\n\r\n/**\r\n * Checks whether a CC application is running on the local machine.\r\n *\r\n * Vulcan Control New 6.x APIs, and Deprecating older Vulcan Control APIs.\r\n * Changes : New isAppRunningEx uses productSAPCodeSpecifiers\r\n *\r\n * @param productSAPCodeSpecifier The application specifier; for example \"ILST-25.2.3\", \"ILST-25\", \"ILST-25.2.3-en_US\" and \"ILST. Refer to `Documentation/CEP 11.1 HTML Extension Cookbook.md#applications-integrated-with-cep` for product SAPCode.\r\n * @return True if the app is running, false otherwise.\r\n */\r\nVulcan.prototype.isAppRunningEx = function (productSAPCodeSpecifier) {\r\n  if (!requiredParamsValid(productSAPCodeSpecifier)) {\r\n    return false;\r\n  }\r\n\r\n  var params = {};\r\n  params.productSAPCodeSpecifier = productSAPCodeSpecifier;\r\n\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\r\n      \"vulcanIsAppRunningEx\",\r\n      JSON.stringify(params)\r\n    )\r\n  ).result;\r\n};\r\n\r\n/**\r\n * Checks whether a CC application is installed on the local machine.\r\n *\r\n * Vulcan Control New 6.x APIs, and Deprecating older Vulcan Control APIs.\r\n * Changes : New isAppInstalledEx uses productSAPCodeSpecifiers\r\n *\r\n * @param productSAPCodeSpecifier The application specifier; for example \"ILST-25.2.3\", \"ILST-25\", \"ILST-25.2.3-en_US\" and \"ILST. Refer to `Documentation/CEP 11.1 HTML Extension Cookbook.md#applications-integrated-with-cep` for product SAPCode.\r\n * @return True if the app is installed, false otherwise.\r\n */\r\nVulcan.prototype.isAppInstalledEx = function (productSAPCodeSpecifier) {\r\n  if (!requiredParamsValid(productSAPCodeSpecifier)) {\r\n    return false;\r\n  }\r\n\r\n  var params = {};\r\n  params.productSAPCodeSpecifier = productSAPCodeSpecifier;\r\n\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\r\n      \"vulcanIsAppInstalledEx\",\r\n      JSON.stringify(params)\r\n    )\r\n  ).result;\r\n};\r\n\r\n/**s\r\n * Retrieves the local install path of a CC application.\r\n *\r\n * Vulcan Control New 6.x APIs, and Deprecating older Vulcan Control APIs.\r\n * Changes : New getAppPathEx uses productSAPCodeSpecifiers\r\n *\r\n * @param productSAPCodeSpecifier The application specifier; for example \"ILST-25.2.3\", \"ILST-25\", \"ILST-25.2.3-en_US\" and \"ILST. Refer to `Documentation/CEP 11.1 HTML Extension Cookbook.md#applications-integrated-with-cep` for product SAPCode.\r\n * @return The path string if the application is found, \"\" otherwise.\r\n */\r\nVulcan.prototype.getAppPathEx = function (productSAPCodeSpecifier) {\r\n  if (!requiredParamsValid(productSAPCodeSpecifier)) {\r\n    return \"\";\r\n  }\r\n\r\n  var params = {};\r\n  params.productSAPCodeSpecifier = productSAPCodeSpecifier;\r\n\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\r\n      \"vulcanGetAppPathEx\",\r\n      JSON.stringify(params)\r\n    )\r\n  ).result;\r\n};\r\n\r\n/**\r\n * DEPRECATED API:: use getTargetSpecifiersEx\r\n * Gets all available application specifiers on the local machine.\r\n *\r\n * @return The array of all available application specifiers.\r\n */\r\nVulcan.prototype.getTargetSpecifiers = function () {\r\n  console.warn(\r\n    \"WARNING! Function 'getTargetSpecifiers' has been deprecated, please use the new 'getTargetSpecifiersEx' function instead!\"\r\n  );\r\n  var params = {};\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\r\n      \"vulcanGetTargetSpecifiers\",\r\n      JSON.stringify(params)\r\n    )\r\n  );\r\n};\r\n\r\n/**\r\n * DEPRECATED API:: use launchAppEx\r\n * Launches a CC application on the local machine, if it is not already running.\r\n *\r\n * @param targetSpecifier The application specifier; for example \"indesign\".\r\n *\r\n *        Note: In Windows 7 64-bit or Windows 8 64-bit system, some target applications (like Photoshop and Illustrator) have both 32-bit version\r\n *        and 64-bit version. Therefore, we need to specify the version by this parameter with \"photoshop-70.032\" or \"photoshop-70.064\". If you\r\n *        installed Photoshop 32-bit and 64-bit on one Windows 64-bit system and invoke this interface with parameter \"photoshop-70.032\", you may\r\n *        receive wrong result.\r\n *        The specifiers for Illustrator is \"illustrator-17.032\", \"illustrator-17.064\", \"illustrator-17\" and \"illustrator\".\r\n *\r\n *        In other platforms there is no such issue, so we can use \"photoshop\" or \"photoshop-70\" as specifier.\r\n * @param focus           True to launch in foreground, or false to launch in the background.\r\n * @param cmdLine         Optional, command-line parameters to supply to the launch command.\r\n * @return True if the app can be launched, false otherwise.\r\n */\r\nVulcan.prototype.launchApp = function (targetSpecifier, focus, cmdLine) {\r\n  console.warn(\r\n    \"WARNING! Function 'launchApp' has been deprecated, please use the new 'launchAppEx' function instead!\"\r\n  );\r\n  if (!requiredParamsValid(targetSpecifier)) {\r\n    return false;\r\n  }\r\n\r\n  var params = {};\r\n  params.targetSpecifier = targetSpecifier;\r\n  params.focus = focus ? \"true\" : \"false\";\r\n  params.cmdLine = requiredParamsValid(cmdLine) ? cmdLine : \"\";\r\n\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\"vulcanLaunchApp\", JSON.stringify(params))\r\n  ).result;\r\n};\r\n\r\n/**\r\n * DEPRECATED API:: use isAppRunningEx\r\n * Checks whether a CC application is running on the local machine.\r\n *\r\n * @param targetSpecifier The application specifier; for example \"indesign\".\r\n *\r\n *        Note: In Windows 7 64-bit or Windows 8 64-bit system, some target applications (like Photoshop and Illustrator) have both 32-bit version\r\n *        and 64-bit version. Therefore, we need to specify the version by this parameter with \"photoshop-70.032\" or \"photoshop-70.064\". If you\r\n *        installed Photoshop 32-bit and 64-bit on one Windows 64-bit system and invoke this interface with parameter \"photoshop-70.032\", you may\r\n *        receive wrong result.\r\n *        The specifiers for Illustrator is \"illustrator-17.032\", \"illustrator-17.064\", \"illustrator-17\" and \"illustrator\".\r\n *\r\n *        In other platforms there is no such issue, so we can use \"photoshop\" or \"photoshop-70\" as specifier.\r\n * @return True if the app is running, false otherwise.\r\n */\r\nVulcan.prototype.isAppRunning = function (targetSpecifier) {\r\n  console.warn(\r\n    \"WARNING! Function 'isAppRunning' has been deprecated, please use the new 'isAppRunningEx' function instead!\"\r\n  );\r\n  if (!requiredParamsValid(targetSpecifier)) {\r\n    return false;\r\n  }\r\n\r\n  var params = {};\r\n  params.targetSpecifier = targetSpecifier;\r\n\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\r\n      \"vulcanIsAppRunning\",\r\n      JSON.stringify(params)\r\n    )\r\n  ).result;\r\n};\r\n\r\n/**\r\n * DEPRECATED API:: use isAppInstalledEx\r\n * Checks whether a CC application is installed on the local machine.\r\n *\r\n * @param targetSpecifier The application specifier; for example \"indesign\".\r\n *\r\n *        Note: In Windows 7 64-bit or Windows 8 64-bit system, some target applications (like Photoshop and Illustrator) have both 32-bit version\r\n *        and 64-bit version. Therefore, we need to specify the version by this parameter with \"photoshop-70.032\" or \"photoshop-70.064\". If you\r\n *        installed Photoshop 32-bit and 64-bit on one Windows 64-bit system and invoke this interface with parameter \"photoshop-70.032\", you may\r\n *        receive wrong result.\r\n *        The specifiers for Illustrator is \"illustrator-17.032\", \"illustrator-17.064\", \"illustrator-17\" and \"illustrator\".\r\n *\r\n *        In other platforms there is no such issue, so we can use \"photoshop\" or \"photoshop-70\" as specifier.\r\n * @return True if the app is installed, false otherwise.\r\n */\r\nVulcan.prototype.isAppInstalled = function (targetSpecifier) {\r\n  console.warn(\r\n    \"WARNING! Function 'isAppInstalled' has been deprecated, please use the new 'isAppInstalledEx' function instead!\"\r\n  );\r\n  if (!requiredParamsValid(targetSpecifier)) {\r\n    return false;\r\n  }\r\n\r\n  var params = {};\r\n  params.targetSpecifier = targetSpecifier;\r\n\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\r\n      \"vulcanIsAppInstalled\",\r\n      JSON.stringify(params)\r\n    )\r\n  ).result;\r\n};\r\n\r\n/**\r\n * DEPRECATED API:: use getAppPathEx\r\n * Retrieves the local install path of a CC application.\r\n *\r\n * @param targetSpecifier The application specifier; for example \"indesign\".\r\n *\r\n *        Note: In Windows 7 64-bit or Windows 8 64-bit system, some target applications (like Photoshop and Illustrator) have both 32-bit version\r\n *        and 64-bit version. Therefore, we need to specify the version by this parameter with \"photoshop-70.032\" or \"photoshop-70.064\". If you\r\n *        installed Photoshop 32-bit and 64-bit on one Windows 64-bit system and invoke this interface with parameter \"photoshop-70.032\", you may\r\n *        receive wrong result.\r\n *        The specifiers for Illustrator is \"illustrator-17.032\", \"illustrator-17.064\", \"illustrator-17\" and \"illustrator\".\r\n *\r\n *        In other platforms there is no such issue, so we can use \"photoshop\" or \"photoshop-70\" as specifier.\r\n * @return The path string if the application is found, \"\" otherwise.\r\n */\r\nVulcan.prototype.getAppPath = function (targetSpecifier) {\r\n  console.warn(\r\n    \"WARNING! Function 'getAppPath' has been deprecated, please use the new 'getAppPathEx' function instead!\"\r\n  );\r\n  if (!requiredParamsValid(targetSpecifier)) {\r\n    return \"\";\r\n  }\r\n\r\n  var params = {};\r\n  params.targetSpecifier = targetSpecifier;\r\n\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\"vulcanGetAppPath\", JSON.stringify(params))\r\n  ).result;\r\n};\r\n\r\n/**\r\n * Registers a message listener callback function for a Vulcan message.\r\n *\r\n * @param type            The message type.\r\n * @param callback        The callback function that handles the message.\r\n *                        Takes one argument, the message object.\r\n * @param obj             Optional, the object containing the callback method, if any.\r\n *                        Default is null.\r\n */\r\nVulcan.prototype.addMessageListener = function (type, callback, obj) {\r\n  if (\r\n    !requiredParamsValid(type, callback) ||\r\n    !strStartsWith(type, VulcanMessage.TYPE_PREFIX)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  var params = {};\r\n  params.type = type;\r\n\r\n  window.__adobe_cep__.invokeAsync(\r\n    \"vulcanAddMessageListener\",\r\n    JSON.stringify(params),\r\n    callback,\r\n    obj\r\n  );\r\n};\r\n\r\n/**\r\n * Removes a registered message listener callback function for a Vulcan message.\r\n *\r\n * @param type            The message type.\r\n * @param callback        The callback function that was registered.\r\n *                        Takes one argument, the message object.\r\n * @param obj             Optional, the object containing the callback method, if any.\r\n *                        Default is null.\r\n */\r\nVulcan.prototype.removeMessageListener = function (type, callback, obj) {\r\n  if (\r\n    !requiredParamsValid(type, callback) ||\r\n    !strStartsWith(type, VulcanMessage.TYPE_PREFIX)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  var params = {};\r\n  params.type = type;\r\n\r\n  window.__adobe_cep__.invokeAsync(\r\n    \"vulcanRemoveMessageListener\",\r\n    JSON.stringify(params),\r\n    callback,\r\n    obj\r\n  );\r\n};\r\n\r\n/**\r\n * Dispatches a Vulcan message.\r\n *\r\n * @param vulcanMessage   The message object.\r\n */\r\nVulcan.prototype.dispatchMessage = function (vulcanMessage) {\r\n  if (\r\n    !requiredParamsValid(vulcanMessage) ||\r\n    !strStartsWith(vulcanMessage.type, VulcanMessage.TYPE_PREFIX)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  var params = {};\r\n  var message = new VulcanMessage(vulcanMessage.type);\r\n  message.initialize(vulcanMessage);\r\n  params.vulcanMessage = message;\r\n\r\n  window.__adobe_cep__.invokeSync(\r\n    \"vulcanDispatchMessage\",\r\n    JSON.stringify(params)\r\n  );\r\n};\r\n\r\n/**\r\n * Retrieves the message payload of a Vulcan message for the registered message listener callback function.\r\n *\r\n * @param vulcanMessage   The message object.\r\n * @return                A string containing the message payload.\r\n */\r\nVulcan.prototype.getPayload = function (vulcanMessage) {\r\n  if (\r\n    !requiredParamsValid(vulcanMessage) ||\r\n    !strStartsWith(vulcanMessage.type, VulcanMessage.TYPE_PREFIX)\r\n  ) {\r\n    return null;\r\n  }\r\n\r\n  var message = new VulcanMessage(vulcanMessage.type);\r\n  message.initialize(vulcanMessage);\r\n  return message.getPayload();\r\n};\r\n\r\n/**\r\n * Gets all available endpoints of the running Vulcan-enabled applications.\r\n *\r\n * Since 7.0.0\r\n *\r\n * @return                The array of all available endpoints.\r\n * An example endpoint string:\r\n * <endPoint>\r\n *   <appId>PHXS</appId>\r\n *   <appVersion>16.1.0</appVersion>\r\n * </endPoint>\r\n */\r\nVulcan.prototype.getEndPoints = function () {\r\n  var params = {};\r\n  return JSON.parse(\r\n    window.__adobe_cep__.invokeSync(\r\n      \"vulcanGetEndPoints\",\r\n      JSON.stringify(params)\r\n    )\r\n  );\r\n};\r\n\r\n/**\r\n * Gets the endpoint for itself.\r\n *\r\n * Since 7.0.0\r\n *\r\n * @return                The endpoint string for itself.\r\n */\r\nVulcan.prototype.getSelfEndPoint = function () {\r\n  var params = {};\r\n  return window.__adobe_cep__.invokeSync(\r\n    \"vulcanGetSelfEndPoint\",\r\n    JSON.stringify(params)\r\n  );\r\n};\r\n\r\n/** Singleton instance of Vulcan **/\r\nvar VulcanInterface = new Vulcan();\r\n\r\n//--------------------------------- Vulcan Message ------------------------------\r\n\r\n/**\r\n * @class VulcanMessage\r\n * Message type for sending messages between host applications.\r\n * A message of this type can be sent to the designated destination\r\n * when appId and appVersion are provided and valid. Otherwise,\r\n * the message is broadcast to all running Vulcan-enabled applications.\r\n *\r\n * To send a message between extensions running within one\r\n * application, use the <code>CSEvent</code> type in CSInterface.js.\r\n *\r\n * @param type            The message type.\r\n * @param appId           The peer appId.\r\n * @param appVersion      The peer appVersion.\r\n *\r\n */\r\nfunction VulcanMessage(type, appId, appVersion) {\r\n  this.type = type;\r\n  this.scope = VulcanMessage.SCOPE_SUITE;\r\n  this.appId = requiredParamsValid(appId)\r\n    ? appId\r\n    : VulcanMessage.DEFAULT_APP_ID;\r\n  this.appVersion = requiredParamsValid(appVersion)\r\n    ? appVersion\r\n    : VulcanMessage.DEFAULT_APP_VERSION;\r\n  this.data = VulcanMessage.DEFAULT_DATA;\r\n}\r\n\r\nVulcanMessage.TYPE_PREFIX = \"vulcan.SuiteMessage.\";\r\nVulcanMessage.SCOPE_SUITE = \"GLOBAL\";\r\nVulcanMessage.DEFAULT_APP_ID = \"UNKNOWN\";\r\nVulcanMessage.DEFAULT_APP_VERSION = \"UNKNOWN\";\r\nVulcanMessage.DEFAULT_DATA = \"<data><payload></payload></data>\";\r\nVulcanMessage.dataTemplate = \"<data>{0}</data>\";\r\nVulcanMessage.payloadTemplate = \"<payload>{0}</payload>\";\r\n\r\n/**\r\n * Initializes this message instance.\r\n *\r\n * @param message         A \\c message instance to use for initialization.\r\n */\r\nVulcanMessage.prototype.initialize = function (message) {\r\n  this.type = message.type;\r\n  this.scope = message.scope;\r\n  this.appId = message.appId;\r\n  this.appVersion = message.appVersion;\r\n  this.data = message.data;\r\n};\r\n\r\n/**\r\n * Retrieves the message data.\r\n *\r\n * @return A data string in XML format.\r\n */\r\nVulcanMessage.prototype.xmlData = function () {\r\n  if (this.data === undefined) {\r\n    var str = \"\";\r\n    str = String.format(VulcanMessage.payloadTemplate, str);\r\n    this.data = String.format(VulcanMessage.dataTemplate, str);\r\n  }\r\n  return this.data;\r\n};\r\n\r\n/**\r\n * Sets the message payload of this message.\r\n *\r\n * @param payload         A string containing the message payload.\r\n */\r\nVulcanMessage.prototype.setPayload = function (payload) {\r\n  var str = cep.encoding.convertion.utf8_to_b64(payload);\r\n  str = String.format(VulcanMessage.payloadTemplate, str);\r\n  this.data = String.format(VulcanMessage.dataTemplate, str);\r\n};\r\n\r\n/**\r\n * Retrieves the message payload of this message.\r\n *\r\n * @return                A string containing the message payload.\r\n */\r\nVulcanMessage.prototype.getPayload = function () {\r\n  var str = GetValueByKey(this.data, \"payload\");\r\n  if (str !== null) {\r\n    return cep.encoding.convertion.b64_to_utf8(str);\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Converts the properties of this instance to a string.\r\n *\r\n * @return The string version of this instance.\r\n */\r\nVulcanMessage.prototype.toString = function () {\r\n  var str = \"type=\" + this.type;\r\n  str += \", scope=\" + this.scope;\r\n  str += \", appId=\" + this.appId;\r\n  str += \", appVersion=\" + this.appVersion;\r\n  str += \", data=\" + this.xmlData();\r\n  return str;\r\n};\r\n\r\n//--------------------------------------- Util --------------------------------\r\n\r\n/**\r\n * Formats a string based on a template.\r\n *\r\n * @param src The format template.\r\n *\r\n * @return The formatted string\r\n */\r\nString.format = function (src) {\r\n  if (arguments.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return src.replace(/\\{(\\d+)\\}/g, function (m, i) {\r\n    return args[i];\r\n  });\r\n};\r\n\r\n/**\r\n * Retrieves the content of an XML element.\r\n *\r\n * @param xmlStr    The XML string.\r\n * @param key       The name of the tag.\r\n *\r\n * @return          The content of the tag, or the empty string\r\n *                  if such tag is not found or the tag has no content.\r\n */\r\nfunction GetValueByKey(xmlStr, key) {\r\n  if (window.DOMParser) {\r\n    var parser = new window.DOMParser();\r\n    try {\r\n      var xmlDoc = parser.parseFromString(xmlStr, \"text/xml\");\r\n      var node = xmlDoc.getElementsByTagName(key)[0];\r\n      if (node && node.childNodes[0]) {\r\n        return node.childNodes[0].nodeValue;\r\n      }\r\n    } catch (e) {\r\n      //log the error\r\n    }\r\n  }\r\n  return \"\";\r\n}\r\n\r\n/**\r\n * Reports whether required parameters are valid.\r\n *\r\n * @return    True if all required parameters are valid,\r\n *            false if any of the required parameters are invalid.\r\n */\r\nfunction requiredParamsValid() {\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var argument = arguments[i];\r\n    if (argument === undefined || argument === null) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Reports whether a string has a given prefix.\r\n *\r\n * @param str       The target string.\r\n * @param prefix    The specific prefix string.\r\n *\r\n * @return          True if the string has the prefix, false if not.\r\n */\r\nfunction strStartsWith(str, prefix) {\r\n  if (typeof str != \"string\") {\r\n    return false;\r\n  }\r\n  return str.indexOf(prefix) === 0;\r\n}\r\n\r\n// Boilerplate Added Export\r\nexport { VulcanMessage };\r\nexport default Vulcan;\r\n","import { CEP_Config } from \"vite-cep-plugin\";\r\nimport { version } from \"./package.json\";\r\n\r\n\r\nconst config: CEP_Config = {\r\n  version,\r\n  id: \"com.nerdzxp.cep\",\r\n  displayName: \"Nerdzxp\",\r\n  symlink: \"local\",\r\n  port: 3000,\r\n  servePort: 5000,\r\n  startingDebugPort: 8860,\r\n  extensionManifestVersion: 6.0,\r\n  requiredRuntimeVersion: 9.0,\r\n  hosts: [\r\n    {\r\n      name: \"AEFT\",\r\n      version: \"[0.0,99.9]\",\r\n    },\r\n    {\r\n      name: \"PPRO\",\r\n      version: \"[0.0,99.9]\",\r\n    },\r\n    {\r\n      name: \"ILST\",\r\n      version: \"[0.0,99.9]\",\r\n    },\r\n    {\r\n      name: \"PHXS\",\r\n      version: \"[0.0,99.9]\",\r\n    },\r\n    {\r\n      name: \"FLPR\",\r\n      version: \"[0.0,99.9]\",\r\n    },\r\n  ],\r\n\r\n  type: \"Panel\",\r\n  iconDarkNormal: \"./src/assets/light-icon.png\",\r\n  iconNormal: \"./src/assets/dark-icon.png\",\r\n  iconDarkNormalRollOver: \"./src/assets/light-icon.png\",\r\n  iconNormalRollOver: \"./src/assets/dark-icon.png\",\r\n  parameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\"],\r\n  width: 500,\r\n  height: 550,\r\n\r\n  panels: [\r\n    {\r\n      mainPath: \"./main/index.html\",\r\n      name: \"main\",\r\n      panelDisplayName: \"Nerdzxp\",\r\n      autoVisible: true,\r\n      width: 600,\r\n      height: 650,\r\n    },\r\n\r\n  ],\r\n  build: {\r\n    jsxBin: \"off\",\r\n    sourceMap: true,\r\n  },\r\n  zxp: {\r\n    country: \"US\",\r\n    province: \"CA\",\r\n    org: \"MyCompany\",\r\n    password: \"mypassword\",\r\n    tsa: \"http://timestamp.digicert.com/\",\r\n    sourceMap: false,\r\n    jsxBin: \"off\",\r\n  },\r\n  installModules: [],\r\n  copyAssets: [],\r\n  copyZipAssets: [],\r\n};\r\nexport default config;\r\n","import config from \"../../cep.config\";\r\nexport const ns = config.id;\r\n","import CSInterface from \"../cep/csinterface\";\r\nimport Vulcan, { VulcanMessage } from \"../cep/vulcan\";\r\nimport { ns } from \"../../../shared/shared\";\r\nimport { fs } from \"../cep/node\";\r\n\r\nexport const csi = new CSInterface();\r\nexport const vulcan = new Vulcan();\r\n\r\n// jsx utils\r\n\r\n/**\r\n * @function EvalES\r\n * Evaluates a string in ExtendScript scoped to the project's namespace\r\n * Optionally, pass true to the isGlobal param to avoid scoping\r\n *\r\n * @param script    The script as a string to be evaluated\r\n * @param isGlobal  Optional. Defaults to false,\r\n *\r\n * @return String Result.\r\n */\r\n\r\nexport const evalES = (script: string, isGlobal = false): Promise<string> => {\r\n  return new Promise(function (resolve, reject) {\r\n    const pre = isGlobal\r\n      ? \"\"\r\n      : `var host = typeof $ !== 'undefined' ? $ : window; host[\"${ns}\"].`;\r\n    const fullString = pre + script;\r\n    csi.evalScript(\r\n      \"try{\" + fullString + \"}catch(e){alert(e);}\",\r\n      (res: string) => {\r\n        resolve(res);\r\n      }\r\n    );\r\n  });\r\n};\r\n\r\nimport type { Scripts } from \"@esTypes/index\";\r\n\r\ntype ArgTypes<F extends Function> = F extends (...args: infer A) => any\r\n  ? A\r\n  : never;\r\ntype ReturnType<F extends Function> = F extends (...args: infer A) => infer B\r\n  ? B\r\n  : never;\r\n\r\n/**\r\n * @description End-to-end type-safe ExtendScript evaluation with error handling\r\n * Call ExtendScript functions from CEP with type-safe parameters and return types.\r\n * Any ExtendScript errors are captured and logged to the CEP console for tracing\r\n *\r\n * @param functionName The name of the function to be evaluated.\r\n * @param args the list of arguments taken by the function.\r\n *\r\n * @return Promise resolving to function native return type.\r\n *\r\n * @example\r\n * // CEP\r\n * evalTS(\"myFunc\", 60, 'test').then((res) => {\r\n *    console.log(res.word);\r\n * });\r\n *\r\n * // ExtendScript\r\n * export const myFunc = (num: number, word: string) => {\r\n *    return { num, word };\r\n * }\r\n *\r\n */\r\n\r\nexport const evalTS = <\r\n  Key extends string & keyof Scripts,\r\n  Func extends Function & Scripts[Key]\r\n>(\r\n  functionName: Key,\r\n  ...args: ArgTypes<Func>\r\n): Promise<ReturnType<Func>> => {\r\n  return new Promise(function (resolve, reject) {\r\n    const formattedArgs = args\r\n      .map((arg) => {\r\n        console.log(JSON.stringify(arg));\r\n        return `${JSON.stringify(arg)}`;\r\n      })\r\n      .join(\",\");\r\n    csi.evalScript(\r\n      `try{\r\n          var host = typeof $ !== 'undefined' ? $ : window;\r\n          var res = host[\"${ns}\"].${functionName}(${formattedArgs});\r\n          JSON.stringify(res);\r\n        }catch(e){\r\n          e.fileName = new File(e.fileName).fsName;\r\n          JSON.stringify(e);\r\n        }`,\r\n      (res: string) => {\r\n        try {\r\n          const parsed = JSON.parse(res);\r\n          if (parsed.name === \"ReferenceError\") {\r\n            console.error(\"REFERENCE ERROR\");\r\n            reject(parsed);\r\n          } else {\r\n            resolve(parsed);\r\n          }\r\n        } catch (error) {\r\n          reject(res);\r\n        }\r\n      }\r\n    );\r\n  });\r\n};\r\n\r\nexport const evalFile = (file: string) => {\r\n  return evalES(\r\n    \"typeof $ !== 'undefined' ? $.evalFile(\\\"\" +\r\n      file +\r\n      '\") : fl.runScript(FLfile.platformPathToURI(\"' +\r\n      file +\r\n      '\"));',\r\n    true\r\n  );\r\n};\r\n\r\n// js utils\r\n\r\nexport const initBolt = (log = true) => {\r\n  if (window.cep) {\r\n    const extRoot = csi.getSystemPath(\"extension\");\r\n    const jsxSrc = `${extRoot}/jsx/index.js`;\r\n    const jsxBinSrc = `${extRoot}/jsx/index.jsxbin`;\r\n    if (fs.existsSync(jsxSrc)) {\r\n      if (log) console.log(jsxSrc);\r\n      evalFile(jsxSrc);\r\n    } else if (fs.existsSync(jsxBinSrc)) {\r\n      if (log) console.log(jsxBinSrc);\r\n      evalFile(jsxBinSrc);\r\n    }\r\n  }\r\n};\r\n\r\nexport const posix = (str: string) => str.replace(/\\\\/g, \"/\");\r\n\r\nexport const openLinkInBrowser = (url: string) => {\r\n  if (window.cep) {\r\n    csi.openURLInDefaultBrowser(url);\r\n  } else {\r\n    location.href = url;\r\n  }\r\n};\r\n\r\nexport const getAppBackgroundColor = () => {\r\n  const { green, blue, red } = JSON.parse(\r\n    window.__adobe_cep__.getHostEnvironment() as string\r\n  ).appSkinInfo.panelBackgroundColor.color;\r\n  return {\r\n    rgb: {\r\n      r: red,\r\n      g: green,\r\n      b: blue,\r\n    },\r\n    hex: `#${red.toString(16)}${green.toString(16)}${blue.toString(16)}`,\r\n  };\r\n};\r\n\r\nexport const subscribeBackgroundColor = (callback: (color: string) => void) => {\r\n  const getColor = () => {\r\n    const newColor = getAppBackgroundColor();\r\n    console.log(\"BG Color Updated: \", { rgb: newColor.rgb });\r\n    const { r, g, b } = newColor.rgb;\r\n    return `rgb(${r}, ${g}, ${b})`;\r\n  };\r\n  // get current color\r\n  callback(getColor());\r\n  // listen for changes\r\n  csi.addEventListener(\r\n    \"com.adobe.csxs.events.ThemeColorChanged\",\r\n    () => callback(getColor()),\r\n    {}\r\n  );\r\n};\r\n\r\n// vulcan\r\n\r\ndeclare type IVulcanMessageObject = {\r\n  event: string;\r\n  callbackID?: string;\r\n  data?: string | null;\r\n  payload?: object;\r\n};\r\n\r\nexport const vulcanSend = (id: string, msgObj: IVulcanMessageObject) => {\r\n  const msg = new VulcanMessage(VulcanMessage.TYPE_PREFIX + id, null, null);\r\n  const msgStr = JSON.stringify(msgObj);\r\n  msg.setPayload(msgStr);\r\n  vulcan.dispatchMessage(msg);\r\n};\r\n\r\nexport const vulcanListen = (id: string, callback: Function) => {\r\n  vulcan.addMessageListener(\r\n    VulcanMessage.TYPE_PREFIX + id,\r\n    (res: any) => {\r\n      var msgStr = vulcan.getPayload(res);\r\n      const msgObj = JSON.parse(msgStr);\r\n      callback(msgObj);\r\n    },\r\n    null\r\n  );\r\n};\r\n\r\nexport const isAppRunning = (targetSpecifier: string) => {\r\n  const { major, minor, micro } = csi.getCurrentApiVersion();\r\n  const version = parseFloat(`${major}.${minor}`);\r\n  if (version >= 11.2) {\r\n    return vulcan.isAppRunningEx(targetSpecifier.toUpperCase());\r\n  } else {\r\n    return vulcan.isAppRunning(targetSpecifier);\r\n  }\r\n};\r\n","export default \"__VITE_ASSET__59a02c7c__\"","export default \"__VITE_ASSET__7ac5db6f__\"","export default \"__VITE_ASSET__d779076f__\"","<script lang=\"ts\">\r\n  import { onMount } from \"svelte\";\r\n  import { os, path } from \"../lib/cep/node\";\r\n  import {\r\n    csi,\r\n    evalES,\r\n    evalFile,\r\n    openLinkInBrowser,\r\n    subscribeBackgroundColor,\r\n    evalTS,\r\n  } from \"../lib/utils/bolt\";\r\n  import { explodeShapeLayers } from \"../../jsx/aeft/aeft\";\r\n\r\n  import nodeJs from \"../assets/node-js.svg\";\r\n  import adobe from \"../assets/adobe.svg\";\r\n  import bolt from \"../assets/bolt-cep.svg\";\r\n\r\n  import \"../index.scss\";\r\n  import \"./main.scss\";\r\n\r\n  let count: number = 0;\r\n  let backgroundColor: string = \"#282c34\";\r\n\r\n  //* Demonstration of Traditional string eval-based ExtendScript Interaction\r\n  const jsxTest = () => {\r\n    console.log(evalES(`helloWorld(\"${csi.getApplicationID()}\")`));\r\n  };\r\n\r\n  //* Demonstration of End-to-End Type-safe ExtendScript Interaction\r\n  const jsxTestTS = () => {\r\n    evalTS(\"helloStr\", \"test\").then((res) => {\r\n      console.log(res);\r\n    });\r\n    evalTS(\"helloNum\", 1000).then((res) => {\r\n      console.log(typeof res, res);\r\n    });\r\n    evalTS(\"helloArrayStr\", [\"ddddd\", \"aaaaaa\", \"zzzzzzz\"]).then((res) => {\r\n      console.log(typeof res, res);\r\n    });\r\n    evalTS(\"helloObj\", { height: 90, width: 100 }).then((res) => {\r\n      console.log(typeof res, res);\r\n      console.log(res.x);\r\n      console.log(res.y);\r\n    });\r\n    evalTS(\"helloError\", \"test\").catch((e) => {\r\n      console.log(\"there was an error\", e);\r\n    });\r\n  };\r\n\r\n  const nodeTest = () => {\r\n    alert(\r\n      `Node.js ${process.version}\\nPlatform: ${\r\n        os.platform\r\n      }\\nFolder: ${path.basename(window.cep_node.global.__dirname)}`\r\n    );\r\n  };\r\n\r\n  onMount(() => {\r\n    if (window.cep) {\r\n      subscribeBackgroundColor((c: string) => (backgroundColor = c));\r\n    }\r\n  });\r\n\r\n  const explode = () => {\r\n    explodeShapeLayers();\r\n  };\r\n</script>\r\n\r\n<div class=\"app\" style=\"background-color: {backgroundColor};\">\r\n  <header class=\"app-header\">\r\n    <img src={bolt} class=\"icon\" alt=\"\" />\r\n    <div class=\"button-group\">\r\n      <button on:click={() => (count += 1)}>Count is: {count}</button>\r\n      <button on:click={nodeTest}>\r\n        <img class=\"icon-button\" src={nodeJs} alt=\"\" />\r\n      </button>\r\n      <button on:click={jsxTest}>\r\n        <img class=\"icon-button\" src={adobe} alt=\"\" />\r\n      </button>\r\n      <button on:click={jsxTestTS}>Ts</button>\r\n    </div>\r\n\r\n    <p>Edit <code>main.svelte</code> and save to test HMR updates.</p>\r\n    <div>\r\n      <button\r\n        class=\"learn-more\"\r\n        on:click={async () => {\r\n          const result = await evalTS(\"explodeShapeLayers\");\r\n        }}>Explode 💣</button\r\n      >\r\n    </div>\r\n  </header>\r\n</div>\r\n\r\n<style>\r\n  /* Add the button styles here */\r\n  :root {\r\n    --bg: #fff;\r\n    --text: #382b22;\r\n    --light-pink: #fff0f0;\r\n    --pink: #ffe9e9;\r\n    --dark-pink: #f9c4d2;\r\n    --pink-border: #b18597;\r\n  }\r\n\r\n  * {\r\n    box-sizing: border-box;\r\n  }\r\n\r\n  *::before,\r\n  *::after {\r\n    box-sizing: border-box;\r\n  }\r\n\r\n  button {\r\n    position: relative;\r\n    display: inline-block;\r\n    cursor: pointer;\r\n    outline: none;\r\n    border: 0;\r\n    vertical-align: middle;\r\n    text-decoration: none;\r\n    font-size: inherit;\r\n    font-family: inherit;\r\n  }\r\n\r\n  .learn-more {\r\n    font-weight: 600;\r\n    color: var(--text);\r\n    text-transform: uppercase;\r\n    padding: 1em 1.2em;\r\n    background: var(--light-pink);\r\n    border: 2px solid var(--pink-border);\r\n    border-radius: 0.75em;\r\n    transform-style: preserve-3d;\r\n    transition: transform 150ms cubic-bezier(0, 0, 0.58, 1),\r\n      background 150ms cubic-bezier(0, 0, 0.58, 1);\r\n  }\r\n\r\n  .learn-more::before {\r\n    position: absolute;\r\n    content: \"\";\r\n    width: 100%;\r\n    height: 100%;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    background: var(--dark-pink);\r\n    border-radius: inherit;\r\n    /* box-shadow: 0 0 0 2px var(--pink-border), 0 0.625em 0 0 var(--pink-shadow); */\r\n    transform: translate3d(0, 0.75em, -1em);\r\n    transition: transform 150ms cubic-bezier(0, 0, 0.58, 1),\r\n      box-shadow 150ms cubic-bezier(0, 0, 0.58, 1);\r\n  }\r\n\r\n  .learn-more:hover {\r\n    background: var(--pink);\r\n    transform: translate(0, 0.25em);\r\n  }\r\n\r\n  .learn-more:hover::before {\r\n    box-shadow: 0 0 0 2px var(--pink-border), 0 0.5em 0 0 var(--pink-shadow);\r\n    transform: translate3d(0, 0.5em, -1em);\r\n  }\r\n\r\n  .learn-more:active {\r\n    background: var(--pink);\r\n    transform: translate(0em, 0.75em);\r\n  }\r\n\r\n  .learn-more:active::before {\r\n    box-shadow: 0 0 0 2px var(--pink-border), 0 0 var(--pink-shadow);\r\n    transform: translate3d(0, 0, -1em);\r\n  }\r\n</style>\r\n","import App from \"./main.svelte\";\r\nimport { initBolt } from \"../lib/utils/bolt\";\r\n\r\ninitBolt();\r\n\r\nconst app = new App({\r\n  target: document.getElementById(\"root\") as Element,\r\n});\r\n\r\nexport default app;\r\n"],"names":["noop","run","fn","blank_object","run_all","fns","is_function","thing","safe_not_equal","a","b","src_url_equal_anchor","src_url_equal","element_src","url","is_empty","obj","append","target","node","insert","anchor","detach","element","name","text","data","space","listen","event","handler","options","attr","attribute","value","children","set_data","set_style","key","important","current_component","set_current_component","component","get_current_component","onMount","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","update_scheduled","schedule_update","flush","add_render_callback","seen_callbacks","flushidx","saved_component","update","e","i","callback","$$","dirty","flush_render_callbacks","filtered","targets","c","outroing","transition_in","block","local","mount_component","customElement","fragment","after_update","new_on_destroy","destroy_component","detaching","make_dirty","init","instance","create_fragment","not_equal","props","append_styles","parent_component","ready","ret","rest","nodes","SvelteComponent","type","callbacks","index","$$props","fs","os","path","MenuItemStatus","menuItemLabel","enabled","checked","ContextMenuItemStatus","menuItemID","CSInterface","urlName","xhr","err","pathName","OSVersion","pathType","script","result","appId","hostCapabilities","listener","extensionId","params","extensionIds","extensionIdsStr","extensionsStr","extensions","networkPre","resourceBundle","resElms","resEl","resKey","resValue","attrKey","userAgent","winVersion","winBit","apiVersion","menu","itemStatus","width","height","keyEventsInterest","title","src","args","m","config","version","ns","csi","evalES","isGlobal","resolve","reject","fullString","res","evalTS","functionName","formattedArgs","arg","parsed","evalFile","file","initBolt","log","extRoot","jsxSrc","jsxBinSrc","getAppBackgroundColor","green","blue","red","subscribeBackgroundColor","getColor","newColor","r","g","nodeJs","adobe","bolt","ctx","img0","img0_src_value","img1","img1_src_value","img2","img2_src_value","div2","header","div0","button0","button1","button2","button3","p","div1","button4","$$invalidate","count","App"],"mappings":"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","x_google_ignoreList":[0]}